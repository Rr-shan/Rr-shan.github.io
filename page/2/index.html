<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Rr-shan,undefined"><meta name="copyright" content="Rr-shan"><title>【Sanzzi】</title><link rel="stylesheet" href="../../css/fan.css"><link rel="stylesheet" href="../../css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="../../favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="../../js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Rr-shan</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Rr-shan" target="_blank">GitHub<i class="icon-dot bg-color7"></i></a><a class="links-button button-hover" href="mailto:1224559633@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="../../archives"><span class="pull-top">日志</span><span class="pull-bottom">40</span></a><a class="author-info-articles-tags article-meta" href="../../tags"><span class="pull-top">标签</span><span class="pull-bottom">11</span></a><a class="author-info-articles-categories article-meta" href="../../categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="https://chao-yin-github.github.io/" target="_blank">yccccc~~~~~~~~</a><a class="friend-link-text" href="https://sanzzi.cn" target="_blank">Mywebsite</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Sanzzi</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="../../2020/02/22/解决IDEA和Pycharm中Vim插件不能与外界粘贴复制/">解决IDEA和Pycharm中Vim插件不能与外界粘贴复制</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-02</time></div><div class="post-content"><div class="main-content content"><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul>
<li><strong>vim 缓冲区</strong>和<strong>系统剪贴板</strong><br>vim 里面粘贴复制实际上是在vim 缓冲区 存取数据，而系统的ctry+c ctry+v 是与系统剪贴板之间的交互<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3></li>
<li>tools工具下点<strong>vim emulation</strong>，再<strong>重新复制</strong><br>（<em>感觉这的确还是很麻烦，但是暂时没有找到更好的办法了</em>）</li>
</ul>
</div></div><a class="button-hover more" href="../../2020/02/22/解决IDEA和Pycharm中Vim插件不能与外界粘贴复制/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="../../2020/02/20/Java垃圾回收机制/">Java垃圾回收机制</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-03</time><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="../../tags/Java/">Java</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><h2 id="垃圾回收的意义"><a href="#垃圾回收的意义" class="headerlink" title="垃圾回收的意义"></a>垃圾回收的意义</h2><p>在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。<br>事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。</p>
<h3 id="这使Java-虚拟机具有一些优点"><a href="#这使Java-虚拟机具有一些优点" class="headerlink" title="这使Java 虚拟机具有一些优点"></a>这使Java 虚拟机具有一些优点</h3><ul>
<li>首先，它能<strong>使编程效率提高</strong>。在没有垃圾回收机制的时候，可能要花许多时间来解决一个<strong>难懂的存储器问题。</strong></li>
<li>其次是它<strong>保护程序的完整性</strong>（？）， 垃圾回收是Java语言安全性策略的一个重要部份。</li>
</ul>
<h3 id="垃圾回收的一个潜在的缺点是它的开销影响程序性能。"><a href="#垃圾回收的一个潜在的缺点是它的开销影响程序性能。" class="headerlink" title="垃圾回收的一个潜在的缺点是它的开销影响程序性能。"></a>垃圾回收的一个潜在的缺点是它的<strong>开销影响程序性能</strong>。</h3><ul>
<li>Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要<strong>花费处理器的时间。</strong></li>
<li>其次<strong>垃圾回收算法的不完备性</strong>，<em>早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。</em>随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。</li>
</ul>
<h2 id="垃圾收集的算法分析"><a href="#垃圾收集的算法分析" class="headerlink" title="垃圾收集的算法分析"></a>垃圾收集的算法分析</h2><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：<br>**1. 发现无用信息对象</p>
<ol start="2">
<li>回收被无用对象占用的内存空间，使该空间可被程序再次使用。**</li>
</ol>
<blockquote>
<p>大多数垃圾回收算法使用了<strong>根集(root set)</strong>这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃圾回收首先需要确定从根开始 <strong>哪些是可达的和哪些是不可达的</strong>，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。</p>
</blockquote>
<h3 id="1-引用计数法-Reference-Counting-Collector"><a href="#1-引用计数法-Reference-Counting-Collector" class="headerlink" title="1. 引用计数法(Reference Counting Collector)"></a>1. 引用计数法(Reference Counting Collector)</h3><p>引用计数法是<strong>唯一没有使用根集的</strong>垃圾回收的算法，该算法使用引用计数器来区分存活对象和不再使用的对象。堆中的每个对象对应一个引用计数器。<em>计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。</em><br>引用计数算法实现简单，效率很高，微软的COM技术、ActionScript、Python等都使用了引用计数算法进行内存管理，但是引用计数算法对于对象之间相互循环引用问题难以解决，因此java并没有使用引用计数算法。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>基于引用计数器的垃圾收集器运行较<strong>快</strong>，<em>对程序需要不被长时间打断的实时环境比较有利。</em></p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p> <strong>无法检测出循环引用</strong>如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0. 而且每次加减<strong>非常浪费内存</strong>。</p>
<h3 id="2-tracing算法-Tracing-Collector"><a href="#2-tracing算法-Tracing-Collector" class="headerlink" title="2. tracing算法(Tracing Collector)"></a>2. tracing算法(Tracing Collector)</h3><p>tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.</p>
<h3 id="3-compacting算法-Compacting-Collector"><a href="#3-compacting算法-Compacting-Collector" class="headerlink" title="3. compacting算法(Compacting Collector)"></a>3. compacting算法(Compacting Collector)</h3><p>为了<strong>解决堆碎片问题</strong>，基于tracing的垃圾回收吸收了<strong>Compacting算法</strong>的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加<strong>句柄和句柄表</strong>。</p>
<p>标记-整理算法在标记-清除算法基础上做了改进，标记阶段是相同的标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。<br>标记-整理算法相比标记-清除算法的优点是内存<strong>被整理以后不会产生大量不连续内存碎片问题。</strong><br>复制算法在<strong>对象存活率高的情况下</strong>就要执行较多的复制操作，效率将会变低，而在对象存活率高的情况下使用标记-整理算法效率会大大提高。</p>
<h3 id="4-copying（复制）算法-Coping-Collector"><a href="#4-copying（复制）算法-Coping-Collector" class="headerlink" title="4. copying（复制）算法(Coping Collector)"></a>4. copying（复制）算法(Coping Collector)</h3><p>该算法的提出是为了<strong>克服句柄的开销和解决堆碎片的垃圾回收</strong>。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。<br>一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，在对象区与空闲区域的切换过程中，程序暂停执行。</p>
<p>S0和s1将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>可使用的内存降为原来一半。</p>
<p>复制算法用于在<strong>新生代垃圾回收</strong></p>
<h3 id="5-generation（分代收集）算法-Generational-Collector"><a href="#5-generation（分代收集）算法-Generational-Collector" class="headerlink" title="5. generation（分代收集）算法(Generational Collector)"></a>5. generation（分代收集）算法(Generational Collector)</h3><p>stop-and-copy垃圾收集器的一个缺陷是<strong>收集器必须复制所有的活动对象</strong>，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代(generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。</p>
<p>根据内存中对象的存活周期不同，将内存划分为几块，java的虚拟机中一般把内存划分为新生代和年老代，当新创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中，当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。<br>对于新生代和老年代来说,新生代回收频率很高,但是每次回收耗时很短,而老年代回收频率较低,但是耗时会相对较长,所以应该尽量减少老年代的GC.</p>
<h3 id="6-adaptive算法-Adaptive-Collector"><a href="#6-adaptive算法-Adaptive-Collector" class="headerlink" title="6. adaptive算法(Adaptive Collector)"></a>6. adaptive算法(Adaptive Collector)</h3><p>　　在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p>
<h2 id="System-gc-方法"><a href="#System-gc-方法" class="headerlink" title="System.gc()方法"></a>System.gc()方法</h2><p>使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestGC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">　　    <span class="keyword">new</span> TestGC();</span><br><span class="line">　　    System.gc();</span><br><span class="line">　　    System.runFinalization();</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips:调用System.gc()也仅仅是一个<strong>请求(建议)</strong>。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。</p>
<h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h2><p>之所以要使用finalize()，是存在着<strong>垃圾回收器不能处理的特殊情况</strong>。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。</p>
<p>特殊的区域如：</p>
<ol>
<li>由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。</li>
<li>又或者打开的<strong>文件资源</strong>，这些资源不属于垃圾回收器的回收范围。</li>
</ol>
<h2 id="触发主GC（Garbage-Collector）的条件"><a href="#触发主GC（Garbage-Collector）的条件" class="headerlink" title="触发主GC（Garbage Collector）的条件"></a>触发主GC（Garbage Collector）的条件</h2><p>JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。<br>总的来说,有两个条件会触发主GC:</p>
<ol>
<li>当<strong>没有应用线程在运行时</strong>,GC会被调用。因为<strong>GC在优先级最低的线程中进行</strong>,所以当应用忙时,GC线程就不会被调用,但以下条件除外。</li>
<li><strong>Java堆内存不足时</strong>,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,<strong>JVM会再进行两次GC</strong>作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。</li>
</ol>
<h2 id="减少GC开销的措施"><a href="#减少GC开销的措施" class="headerlink" title="减少GC开销的措施"></a>减少GC开销的措施</h2><h3 id="1-不要显式调用System-gc"><a href="#1-不要显式调用System-gc" class="headerlink" title="1. 不要显式调用System.gc()"></a>1. 不要显式调用System.gc()</h3><p> 此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</p>
<h3 id="2-尽量减少临时对象的使用"><a href="#2-尽量减少临时对象的使用" class="headerlink" title="2. 尽量减少临时对象的使用"></a>2. 尽量减少临时对象的使用</h3><p> 临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</p>
<h3 id="3-对象不用时最好显式置为Null"><a href="#3-对象不用时最好显式置为Null" class="headerlink" title="3. 对象不用时最好显式置为Null"></a>3. 对象不用时最好显式置为Null</h3><p> 为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</p>
<h3 id="4-尽量使用StringBuffer-而不用String来累加字符串"><a href="#4-尽量使用StringBuffer-而不用String来累加字符串" class="headerlink" title="4. 尽量使用StringBuffer,而不用String来累加字符串"></a>4. 尽量使用StringBuffer,而不用String来累加字符串</h3><p>  由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</p>
<h3 id="5-能用基本类型如Int-Long-就不用Integer-Long对象"><a href="#5-能用基本类型如Int-Long-就不用Integer-Long对象" class="headerlink" title="5.  能用基本类型如Int,Long,就不用Integer,Long对象"></a>5.  能用基本类型如Int,Long,就不用Integer,Long对象</h3><p>基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</p>
<h3 id="6-尽量少用静态对象变量"><a href="#6-尽量少用静态对象变量" class="headerlink" title="6. 尽量少用静态对象变量"></a>6. 尽量少用静态对象变量</h3><p>静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</p>
<h3 id="7-分散对象创建或删除的时间"><a href="#7-分散对象创建或删除的时间" class="headerlink" title="7. 分散对象创建或删除的时间"></a>7. 分散对象创建或删除的时间</h3><p>集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chair</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">boolean</span> gcrun = <span class="keyword">false</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">boolean</span> f = <span class="keyword">false</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">int</span> created = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">int</span> finalized = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">　　Chair() &#123;</span><br><span class="line">　　    i = ++created;</span><br><span class="line">　　    <span class="keyword">if</span>(created == <span class="number">47</span>)</span><br><span class="line">　　　      System.out.println(<span class="string">"Created 47"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　    <span class="keyword">if</span>(!gcrun) &#123;</span><br><span class="line">　　　      gcrun = <span class="keyword">true</span>;</span><br><span class="line">　　　      System.out.println(<span class="string">"Beginning to finalize after "</span> + created + <span class="string">" Chairs have been created"</span>);</span><br><span class="line">　　    &#125;</span><br><span class="line">　　    <span class="keyword">if</span>(i == <span class="number">47</span>) &#123;</span><br><span class="line">　　　      System.out.println(<span class="string">"Finalizing Chair #47， "</span> +<span class="string">"Setting flag to stop Chair creation"</span>);</span><br><span class="line">　　　      f = <span class="keyword">true</span>;</span><br><span class="line">　　    &#125;</span><br><span class="line">　　    finalized++;</span><br><span class="line">　　    <span class="keyword">if</span>(finalized &gt;= created)</span><br><span class="line">　　　      System.out.println(<span class="string">"All "</span> + finalized + <span class="string">" finalized"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Garbage</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span>(args.length == <span class="number">0</span>) &#123;</span><br><span class="line">　　　  System.err.println(<span class="string">"Usage: /n"</span> + <span class="string">"java Garbage before/n or:/n"</span> + <span class="string">"java Garbage after"</span>);</span><br><span class="line">　　　  <span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">while</span>(!Chair.f) &#123;</span><br><span class="line">　　　  <span class="keyword">new</span> Chair();</span><br><span class="line">　　　  <span class="keyword">new</span> String(<span class="string">"To take up space"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　System.out.println(<span class="string">"After all Chairs have been created:/n"</span> + <span class="string">"total created = "</span> + Chair.created +</span><br><span class="line">　　<span class="string">"， total finalized = "</span> + Chair.finalized);</span><br><span class="line">　　<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"before"</span>)) &#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"gc():"</span>);</span><br><span class="line">　　　　System.gc();</span><br><span class="line">　　　　System.out.println(<span class="string">"runFinalization():"</span>);</span><br><span class="line">　　　　System.runFinalization();</span><br><span class="line">　　&#125;</span><br><span class="line">　　System.out.println(<span class="string">"bye!"</span>);</span><br><span class="line">　　<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"after"</span>))</span><br><span class="line">　　　  System.runFinalizersOnExit(<span class="keyword">true</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这个程序创建了许多Chair对象，而且在垃圾收集器开始运行后的某些时候，程序会停止创建Chair。由于垃圾收集器可能在任何时间运行，所以我们不能准确知道它在何时启动。因此，程序用一个名为gcrun的标记来指出垃圾收集器是否已经开始运行。利用第二个标记f，Chair可告诉main()它应停止对象的生成。这两个标记都是在finalize()内部设置的，它调用于垃圾收集期间。另两个static变量–created以及 finalized–分别用于跟踪已创建的对象数量以及垃圾收集器已进行完收尾工作的对象数量。最后，每个Chair都有它自己的（非 static）int i，所以能跟踪了解它具体的编号是多少。编号为47的Chair进行完收尾工作后，标记会设为true，最终结束Chair对象的创建过程。</p>
</blockquote>
<h2 id="关于垃圾回收的几点补充"><a href="#关于垃圾回收的几点补充" class="headerlink" title="关于垃圾回收的几点补充"></a>关于垃圾回收的几点补充</h2><ul>
<li>垃圾收集发生的<strong>不可预知性</strong>：由于实现了不同的垃圾回收算法和采用了不同的收集机制，所以它有可能是定时发生，有可能是当出现系统空闲CPU资源时发生，也有可能是和原始的垃圾收集一样，等到内存消耗出现极限时发生，这与垃圾收集器的选择和具体的设置都有关系。</li>
<li>垃圾收集的实现和<strong>具体的JVM 以及JVM的内存模型</strong>有非常紧密的关系。不同的JVM 可能采用不同的垃圾收集，而<strong>JVM 的内存模型决定着该JVM可以采用哪些类型垃圾收集</strong>。现在，<strong>HotSpot 系列</strong>JVM中的内存系统都采用先进的面向对象的框架设计，这使得该系列JVM都可以采用最先进的垃圾收集。</li>
<li><strong>尽早释放无用对象的引用。</strong>大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的<strong>对象是否被监听</strong>，如果有，则要<strong>去掉监听器，然后再赋空值</strong>。</li>
<li>关键的也是难把握的问题是<strong>内存泄漏</strong>。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。</li>
</ul>
<p>博客参考：<br><a href="https://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="noopener">https://blog.csdn.net/zsuguangh/article/details/6429592</a><br><a href="https://blog.csdn.net/zhangcongyi420/article/details/89060970" target="_blank" rel="noopener">https://blog.csdn.net/zhangcongyi420/article/details/89060970</a></p>
</div></div><a class="button-hover more" href="../../2020/02/20/Java垃圾回收机制/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="../../2020/02/19/leetcode数组类/">leetcode之数组类</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="../../categories/leetcode/">leetcode</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="../../tags/leetcode/">leetcode</a></div></div><div class="post-content"><div class="main-content content"><p><em>使用C/C++做法</em></p>
<h3 id="主要元素"><a href="#主要元素" class="headerlink" title="主要元素"></a>主要元素</h3><p><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-majority-element-lcci/</a></p>
<p>快排</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i + k &lt; numsSize ;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] == nums[i+k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超时</p>
<blockquote>
<p><strong>摩尔投票算法</strong>是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。<br>核心就是<strong>对拼消耗</strong>。<br>知乎讲解：<a href="https://www.zhihu.com/question/49973163" target="_blank" rel="noopener">https://www.zhihu.com/question/49973163</a></p>
</blockquote>
<h2 id="消失的数字"><a href="#消失的数字" class="headerlink" title="消失的数字"></a>消失的数字</h2><p><a href="https://leetcode-cn.com/problems/missing-number-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/missing-number-lcci/</a></p>
<blockquote>
<p>M：<br>构建一个辅助数组，遇到了就是0，没有遇到就是1，最后再找到那个值</p>
</blockquote>
<ol>
<li><p>第一种方法：<br>1）计算总和<br>2）用数列公式 - 总和</p>
</li>
<li><p>第二种方法：<br>1）边加边减</p>
</li>
</ol>
<h2 id="合并排序的数组"><a href="#合并排序的数组" class="headerlink" title="合并排序的数组"></a>合并排序的数组</h2><p><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sorted-merge-lcci/</a></p>
<blockquote>
<p>方法 1: 直接合并后排序<br>方法 2: 双指针<br>方法3：逆向双指针 （不需要额外开辟空间，但前提是前一个的容量要足够大）</p>
</blockquote>
<h2 id="连续数列"><a href="#连续数列" class="headerlink" title="连续数列"></a>连续数列</h2><p><a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contiguous-sequence-lcci/</a></p>
<blockquote>
<p>题的关键是要理解这么一层含义：对于数组 nums = [5, -9, 6, -2, 3]，5 是否要加 -9，取决于 -9 后面的正数是否能抵消 -9 并还有剩余。<br>一般称这种为贪心问题</p>
</blockquote>
<p><strong>动态规划</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.length;i++)&#123;</span><br><span class="line">			<span class="comment">//b = b&lt;0? nums[i]:b+nums[i];</span></span><br><span class="line">            <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                b=nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b&gt;sum)&#123;</span><br><span class="line">                sum=b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分治算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分治法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    <span class="keyword">return</span> divide(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 1. 最大数列和在左边</span></span><br><span class="line">    <span class="keyword">int</span> sumLeft = divide(nums,left,mid);</span><br><span class="line">    <span class="comment">// 2. 最大数列和在右边</span></span><br><span class="line">    <span class="keyword">int</span> sumRight = divide(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="comment">// 3. 最大数列和在中间</span></span><br><span class="line">    <span class="comment">// 先求左边的最大和</span></span><br><span class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>,leftMaxSum = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= left; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">        leftMaxSum = max(leftMaxSum,leftSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求右边的最大和</span></span><br><span class="line">    <span class="keyword">int</span> rightSum = <span class="number">0</span>,rightMaxSum = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rightSum += nums[i];</span><br><span class="line">        rightMaxSum = max(rightMaxSum,rightSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(max(sumLeft,sumRight),leftMaxSum+rightMaxSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在排序数组中查找数字-I"><a href="#在排序数组中查找数字-I" class="headerlink" title="在排序数组中查找数字 I"></a>在排序数组中查找数字 I</h2><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</a></p>
<p><strong>二分查找法找到第一次出现的位置和最后一次出现的位置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span>; j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="../../2020/02/19/leetcode数组类/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="../../2020/02/18/递归思想&amp;递归转化成非递归/">递归思想&amp;递归转化成非递归</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="../../categories/数据结构/">数据结构</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="../../tags/数据结构/">数据结构</a></div></div><div class="post-content"><div class="main-content content"><h2 id="递归理解"><a href="#递归理解" class="headerlink" title="递归理解"></a>递归理解</h2><p><em>递归思想</em>就是：<strong>把问题分解成规模更小，但和原问题有着相同解法的问题。</strong><br><em>典型的问题</em>有<strong>汉诺塔问题，斐波那契数列，二分查找问题，快速排序问题</strong>等。<br>其实像我们常见的<strong>分治法和动态规划法</strong>都是递归思想的经典应用。</p>
<p><strong>最关键的：</strong><br>存在一个能让递归调用退出的<strong>出口</strong>。</p>
<h2 id="递归、循环、迭代、遍历的区别"><a href="#递归、循环、迭代、遍历的区别" class="headerlink" title="递归、循环、迭代、遍历的区别"></a>递归、循环、迭代、遍历的区别</h2><ul>
<li>递归：一个函数反复调用自身的行为，特指函数本身；</li>
<li>循环：满足一定条件下，重复执行某些行为，如while结构；</li>
<li>迭代：按某种规则执行一个序列中的每一项，如for结构；</li>
<li>遍历：按某种规则访问图形结构中每一个节点，特指图形结构。</li>
</ul>
<h2 id="递归过程初分析"><a href="#递归过程初分析" class="headerlink" title="递归过程初分析"></a>递归过程初分析</h2><p>在大多数机器上，每次调用函数时大致要做三个工作：调用前先<strong>保存寄存器</strong>，并在返回时恢复；复制实参；程序必须转向一个新位置执行。<br>其中，具体要保存的内容包括：局部变量、形参、调用函数地址、返回值。那么，如果递归调用N次，就要分配N<em>局部变量、N</em>形参、N<em>调用函数地址、N</em>返回值。这势必是影响效率的。</p>
<h2 id="递归转非递归的方法"><a href="#递归转非递归的方法" class="headerlink" title="递归转非递归的方法"></a>递归转非递归的方法</h2><ol>
<li>第一种情况：<strong>递归转尾递归</strong>的问题，这类问题可以不借助堆栈结构将递归转化为循环结构。</li>
<li>第二种情况：借助堆栈将递归转化为非递归（PS：任何递归都可以借助堆栈转化成非递归，第一种情况严格意义上来说不能看做是一种情况）。<br>其中，第二种情况又可以进一步分为两种转化方法：<ol>
<li>第一种方法：<strong>借助堆栈模拟递归的执行过程。</strong>这种方法几乎是<strong>通用</strong>的方法，因为递归本身就是通过堆栈实现的，我们只要把递归函数调用的局部变量和相应的状态放入到一个栈结构中，在函数调用和返回时做好push和pop操作，就可以了（<strong>模拟快排</strong>的例子）。</li>
<li>第二种方法：借助堆栈的循环结构算法。这种方法常常适用于某些局部变量有依赖关系，且需要重复执行的场景，例如<strong>二叉树的遍历算法</strong>，就采用的这种方法。</li>
</ol>
</li>
</ol>
<p><em>延伸问题:</em><br>在斐波那契数列中，如果兔子永远不死，一直繁衍下去，则怎么解？很明显，这是个大数问题。</p>
<p>参考：<br><a href="https://www.cnblogs.com/bakari/p/5349383.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/5349383.html</a></p>
</div></div><a class="button-hover more" href="../../2020/02/18/递归思想&amp;递归转化成非递归/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="../../2020/02/17/pandas读取excel/">pandas读取excel</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h4 id="pandas处理excel数据非常便捷"><a href="#pandas处理excel数据非常便捷" class="headerlink" title="pandas处理excel数据非常便捷"></a>pandas处理excel数据非常便捷</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">r'F:\C\train_01.xlsx'</span>)</span><br><span class="line">data=df.loc[:,[<span class="string">'留言详情'</span>,<span class="string">'一级分类'</span>]].values<span class="comment">#读所有行的title以及data列的值，这里需要嵌套列表</span></span><br><span class="line"><span class="comment"># data=df.loc[:,['留言详情']].values</span></span><br><span class="line">print(<span class="string">"读取指定行的数据：\n&#123;0&#125;"</span>.format(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'numpy.ndarray'&gt; 将此转化成列表</span></span><br><span class="line">x = df.stack().tolist()</span><br><span class="line"></span><br><span class="line">data_01=[]</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> x:</span><br><span class="line">    sentence = line.strip().replace(<span class="string">u'\u3000'</span>, <span class="string">u' '</span>).replace(<span class="string">u'\xa0'</span>, <span class="string">u' '</span>).replace(<span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">"\r"</span>, <span class="string">""</span>).replace(<span class="string">"\n"</span>, <span class="string">""</span>)</span><br><span class="line">    data_01.append(sentence) </span><br><span class="line">    </span><br><span class="line"><span class="comment"># \u3000 是全角的空白符</span></span><br><span class="line"><span class="comment"># 终于把\n和\r给换掉了</span></span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="../../2020/02/17/pandas读取excel/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="../../2020/02/16/Kmeans聚类入门/">Kmeans聚类入门</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><p>Kmeans聚类入门</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">data = np.random.rand(<span class="number">100</span>, <span class="number">3</span>) <span class="comment">#生成一个随机数据，样本大小为100, 特征数为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#假如我要构造一个聚类数为3的聚类器</span></span><br><span class="line">estimator = KMeans(n_clusters=<span class="number">3</span>)<span class="comment">#构造聚类器</span></span><br><span class="line">estimator.fit(data)<span class="comment">#聚类</span></span><br><span class="line">label_pred = estimator.labels_ <span class="comment">#获取聚类标签</span></span><br><span class="line">centroids = estimator.cluster_centers_ <span class="comment">#获取聚类中心</span></span><br><span class="line">inertia = estimator.inertia_ <span class="comment"># 获取聚类准则的总和</span></span><br><span class="line"></span><br><span class="line">print(label_pred)</span><br><span class="line">print(centroids)</span><br><span class="line">print(inertia)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当数据量很大的时候，Kmeans 显然还是很弱的，会比较耗费内存速度也会收到很大影响。scikit-learn 提供了MiniBatchKMeans算法，大致思想就是对数据进行抽样，每次不使用所有的数据来计算，这就会导致准确率的损失。</p>
</blockquote>
<p>做了实验后，文本聚类效果不是很好（直接使用可视化），原因：数据太少了。</p>
</div></div><a class="button-hover more" href="../../2020/02/16/Kmeans聚类入门/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="../../2020/02/15/springcloud/">SpringCloud</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="../../categories/后台开发/">后台开发</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="../../tags/SpringBoot/">SpringBoot</a></div></div><div class="post-content"><div class="main-content content"><p>纯洁的微笑关于springcloud的知识是2017年的</p>
<p>在使用了一段时间后发现Spring Cloud从技术架构上降低了对大型系统构建的要求，使我们以非常低的成本（技术或者硬件）搭建一套高效、分布式、容错的平台，但Spring Cloud也不是没有缺点，小型独立的项目不适合使用。</p>
<p>Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<ol>
<li>大话Spring Cloud 核心成员的介绍</li>
</ol>
<p>目前，国内使用 Spring Cloud 技术的公司并不多见，不是因为 Spring Cloud 不好，主要原因有以下几点：</p>
<ol>
<li>Spring Cloud 中文文档较少，出现问题网上没有太多的解决方案。</li>
<li>国内创业型公司技术老大大多是阿里系员工，而阿里系多采用 Dubbo 来构建微服务架构。（阿里已经采用了）</li>
<li>大型公司基本都有自己的分布式解决方案，而中小型公司的架构很多用不上微服务，所以没有采用 Spring Cloud 的必要性。</li>
</ol>
</div></div><a class="button-hover more" href="../../2020/02/15/springcloud/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="../../2020/02/14/shortUrl/">Springboot实战项目——短链接设计</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="../../categories/后台开发/">后台开发</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="../../tags/SpringBoot/">SpringBoot</a></div></div><div class="post-content"><div class="main-content content"><hr>
<p>短链接的生成，可以有两种方法。<br>第一种，直接调用百度API一类网址生成短链接<br>第二种，当我们生成短链接之后，只需要在表中（数据库或者NoSql ）存储原始链接与短链接的<strong>映射关系</strong>即可。当我们访问短链接时，只需要从映射关系中找到原始链接，即可跳转到原始链接。</p>
<h2 id="SpringBoot连接Mysql数据库"><a href="#SpringBoot连接Mysql数据库" class="headerlink" title="SpringBoot连接Mysql数据库"></a>SpringBoot连接Mysql数据库</h2><blockquote>
<p>　Spring连接Mysql的方式有很多，例如JDBC，Spring JPA，Hibeirnate，Mybatis等</p>
</blockquote>
<h4 id="JDBC依赖导入"><a href="#JDBC依赖导入" class="headerlink" title="JDBC依赖导入"></a>JDBC依赖导入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置数据库的文件"><a href="#配置数据库的文件" class="headerlink" title="配置数据库的文件"></a>配置数据库的文件</h4><p>(喜欢yml)</p>
<ul>
<li><p>application.properties</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url: jdbc:mysql://127.0.0.1:3306/DataName?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT</span><br><span class="line">spring.datasource.username:root</span><br><span class="line">spring.datasource.password:root</span><br><span class="line">spring.datasource.driver-class-name:com.mysql.jdbc</span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#   数据源基本配置</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="attr">dbc:mysql://192.168.26.128:3306/Mybatis?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>1.创建数据库（shorturl），创建一个表，存储长链接和与之对应的短链接；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`link`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`long_url`</span> <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'长链接'</span>,</span><br><span class="line">  <span class="string">`short_url`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'短链接'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- AUTO_INCREMENT 自增 AUTO_INCREMENT=1 从开始增加</span></span><br><span class="line"><span class="comment">-- PRIMAPY是主键的意思，表示定义的该列值在表中是唯一的意思，不可以有重复。</span></span><br><span class="line"><span class="comment">-- ENGINE InnoDB锁定表中的特定行，并MyISAM锁定整个MySQL表。</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="连接虚拟机的数据库"><a href="#连接虚拟机的数据库" class="headerlink" title="连接虚拟机的数据库"></a>连接虚拟机的数据库</h2><h3 id="查看电脑的IP地址"><a href="#查看电脑的IP地址" class="headerlink" title="查看电脑的IP地址"></a>查看电脑的IP地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>

<p>192.168.26.128</p>
<h4 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 名字 建表 </span><br><span class="line"><span class="keyword">use</span> 数据库名; //到达某一数据库</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; //列出所有表</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">link</span>(<span class="keyword">id</span>,long_url,short_url)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">'1'</span>,<span class="string">'https://jingyan.baidu.com/article/ca41422f0be18e1eae99ed15.html'</span>,<span class="string">'Abj876'</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p>查看前端向后台发送的请求:F12 -&gt; network -&gt; XHR</p>
<h3 id="懒人站长"><a href="#懒人站长" class="headerlink" title="懒人站长"></a>懒人站长</h3><p><a href="http://www.ab173.com/zhanzhang/getheader.php" target="_blank" rel="noopener">http://www.ab173.com/zhanzhang/getheader.php</a><br>查看网页HTTP状态代码检测<br>测试<br>新浪网址（永久短网址） 查不出状态码<br>百度短网址 返回302<br>加密短网址 返回302<br>腾讯短网址 返回302</p>
<h4 id="get和post请求"><a href="#get和post请求" class="headerlink" title="get和post请求"></a>get和post请求</h4><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<blockquote>
<p>HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p>
</blockquote>
<blockquote>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。<br>参考博客：<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener">https://www.cnblogs.com/logsharing/p/8448446.html</a><br>风格挺有意思的</p>
</blockquote>
<h3 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h3><h5 id="映射实体类的数据类型"><a href="#映射实体类的数据类型" class="headerlink" title="映射实体类的数据类型"></a>映射实体类的数据类型</h5><p>resultMap: 唯一标识<br>column: 库表的字段名<br>property： 实体类里的属性名</p>
<p>配置映射文件：(摘自网络)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace:当前库表映射文件的命名空间，唯一的不能重复 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.hao947.sql.mapper.PersonMapper"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- type:映射实体类的数据类型 id：resultMap的唯一标识 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"person"</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- column:库表的字段名 property:实体类里的属性名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"person_id"</span> <span class="attr">property</span>=<span class="string">"personId"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"person_addr"</span> <span class="attr">property</span>=<span class="string">"personAddr"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"birthday"</span> <span class="attr">property</span>=<span class="string">"birthday"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--id:当前sql的唯一标识</span></span><br><span class="line"><span class="comment">     parameterType：输入参数的数据类型 </span></span><br><span class="line"><span class="comment">     resultType：返回值的数据类型 </span></span><br><span class="line"><span class="comment">     #&#123;&#125;:用来接受参数的，如果是传递一个参数#&#123;id&#125;内容任意，如果是多个参数就有一定的规则,采用的是预编译的形式select </span></span><br><span class="line"><span class="comment">    * from person p where p.id = ? ，安全性很高 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>yml文件的key与value之间必须至少空一空格</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">mapper-locations:</span> <span class="attr">classpath:mapper/*.xml</span></span><br><span class="line"><span class="comment"># it is forbidden to  specify block composed value at the same line as key classpath后面不能空格</span></span><br></pre></td></tr></table></figure>

<h5 id="Maven与Gradle的对比"><a href="#Maven与Gradle的对比" class="headerlink" title="Maven与Gradle的对比"></a>Maven与Gradle的对比</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span>(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-web"</span>) &#123;</span><br><span class="line">        <span class="keyword">exclude</span> module: <span class="string">"spring-boot-starter-tomcat"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-security"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-data-jpa"</span>)</span><br><span class="line">    testCompile(<span class="string">"mysql:mysql-connector-java:5.1.25"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细阅读下你会发现，原来是依赖管理所需的配置长度变短了。在pom.xml中我们需要引入一个依赖时需要将它的groupId, artifactId和version都用标签引起来。但是在build.gradle中你会发现，仅仅需要将三者的value用:连起来，并”调用compile函数”就可以啦。</p>
<p>这个是记录操作路上的磕磕盼盼，参考价值可能不大。</p>
<p>过程思想推荐：<br><a href="https://www.cnblogs.com/rjzheng/p/11827426.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/11827426.html</a></p>
</div></div><a class="button-hover more" href="../../2020/02/14/shortUrl/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="../../2020/02/13/Python词云/">Python词云</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="../../categories/Pyhton/">Pyhton</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="../../tags/sth-interesting/">sth.interesting</a></div></div><div class="post-content"><div class="main-content content"><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy matplotlib pillow wordcloud imageio jieba snownlp itchat -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>用清华的镜像速度好评</p>
<p>网上提供的图片素材太少了，只好用自己一般的画工作图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入imageio库中的imread函数，并用这个函数读取本地图片，作为词云形状图片</span></span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line">mk = imageio.imread(<span class="string">"xiaolan.png"</span>)</span><br><span class="line">w = wordcloud.WordCloud(mask=mk)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建并配置词云对象w，注意要加scale参数，提高清晰度</span></span><br><span class="line">w = wordcloud.WordCloud(width=<span class="number">1000</span>,</span><br><span class="line">                        height=<span class="number">700</span>,</span><br><span class="line">                        background_color=<span class="string">'white'</span>,</span><br><span class="line">                        font_path=<span class="string">'simkai.ttf'</span>,</span><br><span class="line">                        mask=mk,</span><br><span class="line">                        scale=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对来自外部文件的文本进行中文分词，得到string  ，有可能会遇到编码问题，这个可以根据报错来</span></span><br><span class="line">f = open(<span class="string">'知乎甜话.txt'</span>)</span><br><span class="line">txt = f.read()</span><br><span class="line">txtlist = jieba.lcut(txt)</span><br><span class="line">string = <span class="string">" "</span>.join(txtlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将string变量传入w的generate()方法，给词云输入文字</span></span><br><span class="line">w.generate(string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将词云图片导出到当前文件夹</span></span><br><span class="line">w.to_file(<span class="string">'chao1.png'</span>)</span><br></pre></td></tr></table></figure>

<p>上传不了图片！</p>
<p>TODO：颜色 &amp; 字体</p>
</div></div><a class="button-hover more" href="../../2020/02/13/Python词云/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="../../2020/02/12/NLP入门之文本分类/">NLP入门之文本分类</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="../../categories/NLP/">NLP</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="../../tags/NLP/">NLP</a></div></div><div class="post-content"><div class="main-content content"><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlrd <span class="comment"># 也可以使用pandas处理excel，非常好用</span></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">r'F:\C_1\train\train.xlsx'</span>)</span><br><span class="line">sheet = workbook.sheet_by_index(<span class="number">0</span>) <span class="comment"># sheet索引从0开始</span></span><br><span class="line">cols_1 = sheet.col_values(<span class="number">4</span>) <span class="comment"># 获取第3列内容</span></span><br><span class="line">cols_2 = sheet.col_values(<span class="number">5</span>)</span><br><span class="line">X_train = cols_1</span><br><span class="line">y_train = cols_2</span><br><span class="line"></span><br><span class="line">workbook1 = xlrd.open_workbook(<span class="string">r'F:\C_1\test\test.xlsx'</span>)</span><br><span class="line">sheet = workbook1.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">cols_3 = sheet.col_values(<span class="number">4</span>)</span><br><span class="line">cols_4 = sheet.col_values(<span class="number">5</span>)</span><br><span class="line">X_test = cols_3</span><br><span class="line">y_test = cols_4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉空格</span></span><br><span class="line">X_train_word = [jieba.cut(words) <span class="keyword">for</span> words <span class="keyword">in</span> X_train]</span><br><span class="line">X_train_cut = [<span class="string">' '</span>.join(word) <span class="keyword">for</span> word <span class="keyword">in</span> X_train_word]</span><br><span class="line">X_test_word = [jieba.cut(words) <span class="keyword">for</span> words <span class="keyword">in</span> X_test]</span><br><span class="line">X_test_cut  = [<span class="string">' '</span>.join(word) <span class="keyword">for</span> word <span class="keyword">in</span> X_test_word]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 停止词使用</span></span><br><span class="line">stoplist = [word.strip() <span class="keyword">for</span> word <span class="keyword">in</span> open(<span class="string">'F:\MLstudy\stop\stopword.txt'</span>, \</span><br><span class="line">                                           encoding=<span class="string">'utf-8'</span>).readlines()]</span><br><span class="line"><span class="comment"># from sklearn.preprocessing import LabelEncoder</span></span><br><span class="line">le = LabelEncoder()</span><br><span class="line">y_train_le = le.fit_transform(y_train)</span><br><span class="line">y_test_le  = le.fit_transform(y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#文本数据转换成数据值数据矩阵</span></span><br><span class="line"><span class="comment"># from sklearn.feature_extraction.text import CountVectorizer</span></span><br><span class="line">count = CountVectorizer(stop_words=stoplist)</span><br><span class="line"></span><br><span class="line">count.fit(list(X_train_cut) + list(X_test_cut))</span><br><span class="line">X_train_count = count.transform(X_train_cut)</span><br><span class="line">X_test_count  = count.transform(X_test_cut)</span><br><span class="line"></span><br><span class="line">X_train_count = X_train_count.toarray()</span><br><span class="line">X_test_count  = X_test_count.toarray()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存储所有算法的名字，准确率和所消耗的时间</span></span><br><span class="line">estimator_list, score_list, time_list = [], [], []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_text_classification</span><span class="params">(estimator, X, y, X_test, y_test)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    estimator: 分类器，必选参数</span></span><br><span class="line"><span class="string">            X: 特征训练数据，必选参数</span></span><br><span class="line"><span class="string">            y: 标签训练数据，必选参数</span></span><br><span class="line"><span class="string">       X_test: 特征测试数据，必选参数</span></span><br><span class="line"><span class="string">        y_tes: 标签测试数据，必选参数</span></span><br><span class="line"><span class="string">       return: 返回值</span></span><br><span class="line"><span class="string">           y_pred_model: 预测值</span></span><br><span class="line"><span class="string">             classifier: 分类器名字</span></span><br><span class="line"><span class="string">                  score: 准确率</span></span><br><span class="line"><span class="string">                      t: 消耗的时间</span></span><br><span class="line"><span class="string">                  matrix: 混淆矩阵</span></span><br><span class="line"><span class="string">                  report: 分类评价函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法正在启动，请稍候...'</span>)</span><br><span class="line">    model = estimator</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法正在进行训练，请稍候...'</span>)</span><br><span class="line">    model.fit(X, y)</span><br><span class="line">    print(model)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法正在进行预测，请稍候...'</span>)</span><br><span class="line">    y_pred_model = model.predict(X_test)</span><br><span class="line">    print(y_pred_model)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法正在进行性能评估，请稍候...'</span>)</span><br><span class="line">    score = metrics.accuracy_score(y_test, y_pred_model)</span><br><span class="line">    matrix = metrics.confusion_matrix(y_test, y_pred_model)</span><br><span class="line">    report = metrics.classification_report(y_test, y_pred_model)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#     f1 = metrics.f1_score(y_test, y_pred_model,average='weighted') #这是加权的</span></span><br><span class="line">    f1 = metrics.f1_score(y_test, y_pred_model, average=<span class="string">'macro'</span>)</span><br><span class="line">    print(<span class="string">'&gt;&gt;&gt;准确率\n'</span>, score)</span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;混淆矩阵\n'</span>, matrix)</span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;召回率\n'</span>, report)</span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;F1 score\n'</span>, f1)</span><br><span class="line">    print(<span class="string">'&gt;&gt;&gt;算法程序已经结束...'</span>)</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    t = end - start</span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法消耗时间为：'</span>, t, <span class="string">'秒\n'</span>)</span><br><span class="line">    classifier = str(model).split(<span class="string">'('</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_pred_model, classifier, score, round(t, <span class="number">2</span>), matrix, report</span><br></pre></td></tr></table></figure>

<h2 id="方法1——k-近邻算法"><a href="#方法1——k-近邻算法" class="headerlink" title="方法1——k 近邻算法"></a>方法1——k 近邻算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">knc = KNeighborsClassifier()</span><br><span class="line">result = get_text_classification(knc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法2——决策树"><a href="#方法2——决策树" class="headerlink" title="方法2——决策树"></a>方法2——决策树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">dtc = DecisionTreeClassifier()</span><br><span class="line">result = get_text_classification(dtc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法3——多层感知器"><a href="#方法3——多层感知器" class="headerlink" title="方法3——多层感知器"></a>方法3——多层感知器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line"></span><br><span class="line">mlpc = MLPClassifier()</span><br><span class="line">result = get_text_classification(mlpc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法4——伯努力贝叶斯算法"><a href="#方法4——伯努力贝叶斯算法" class="headerlink" title="方法4——伯努力贝叶斯算法"></a>方法4——伯努力贝叶斯算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> BernoulliNB</span><br><span class="line"></span><br><span class="line">bnb = BernoulliNB()</span><br><span class="line">result = get_text_classification(bnb, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法5——高斯贝叶斯"><a href="#方法5——高斯贝叶斯" class="headerlink" title="方法5——高斯贝叶斯"></a>方法5——高斯贝叶斯</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line">gnb = GaussianNB()</span><br><span class="line">result = get_text_classification(gnb, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法6——多项式朴素贝叶斯"><a href="#方法6——多项式朴素贝叶斯" class="headerlink" title="方法6——多项式朴素贝叶斯"></a>方法6——多项式朴素贝叶斯</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"></span><br><span class="line">mnb = MultinomialNB()</span><br><span class="line">result = get_text_classification(mnb, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法7——逻辑回归算法"><a href="#方法7——逻辑回归算法" class="headerlink" title="方法7——逻辑回归算法"></a>方法7——逻辑回归算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">lgr = LogisticRegression()</span><br><span class="line">result = get_text_classification(lgr, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法8——支持向量机算法"><a href="#方法8——支持向量机算法" class="headerlink" title="方法8——支持向量机算法"></a>方法8——支持向量机算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line">svc = svm.SVC()</span><br><span class="line">result = get_text_classification(svc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="集成学习算法——方法1——随机森林算法"><a href="#集成学习算法——方法1——随机森林算法" class="headerlink" title="集成学习算法——方法1——随机森林算法"></a>集成学习算法——方法1——随机森林算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line">rfc = RandomForestClassifier()</span><br><span class="line">result = get_text_classification(rfc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="集成学习算法——方法2——自增强算法"><a href="#集成学习算法——方法2——自增强算法" class="headerlink" title="集成学习算法——方法2——自增强算法"></a>集成学习算法——方法2——自增强算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"></span><br><span class="line">abc = AdaBoostClassifier()</span><br><span class="line">result = get_text_classification(abc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="集成学习算法——方法3——lightgbm算法"><a href="#集成学习算法——方法3——lightgbm算法" class="headerlink" title="集成学习算法——方法3——lightgbm算法"></a>集成学习算法——方法3——lightgbm算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lightgbm</span><br><span class="line"></span><br><span class="line">gbm = lightgbm.LGBMClassifier()</span><br><span class="line">result = get_text_classification(gbm, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="集成学习算法——方法4——xgboost算法"><a href="#集成学习算法——方法4——xgboost算法" class="headerlink" title="集成学习算法——方法4——xgboost算法"></a>集成学习算法——方法4——xgboost算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost</span><br><span class="line"></span><br><span class="line">xgb = xgboost.XGBClassifier()</span><br><span class="line">result = get_text_classification(xgb, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="深度学习算法——方法1——多分类前馈神经网络"><a href="#深度学习算法——方法1——多分类前馈神经网络" class="headerlink" title="深度学习算法——方法1——多分类前馈神经网络"></a>深度学习算法——方法1——多分类前馈神经网络</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> keras.utils.np_utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="comment"># --------------------------------</span></span><br><span class="line"><span class="comment"># np.random.seed(0)     # 设置随机数种子</span></span><br><span class="line">feature_num = X_train_count.shape[<span class="number">1</span>]     <span class="comment"># 设置所希望的特征数量</span></span><br><span class="line"><span class="comment"># print(feature_num)</span></span><br><span class="line"><span class="comment"># ---------------------------------</span></span><br><span class="line"><span class="comment"># 独热编码目标向量来创建目标矩阵</span></span><br><span class="line">y_train_cate = to_categorical(y_train_le)</span><br><span class="line">y_test_cate = to_categorical(y_test_le)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 1 创建神经网络</span></span><br><span class="line">network = models.Sequential() </span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 2 添加神经连接层</span></span><br><span class="line"><span class="comment"># 第一层必须有并且一定是 [输入层], 必选</span></span><br><span class="line">network.add(layers.Dense(     <span class="comment"># 添加带有 relu 激活函数的全连接层</span></span><br><span class="line">                         units=<span class="number">128</span>, </span><br><span class="line">                         activation=<span class="string">'relu'</span>, </span><br><span class="line">                         input_shape=(feature_num, )</span><br><span class="line">                         ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 介于第一层和最后一层之间的称为 [隐藏层]，可选</span></span><br><span class="line">network.add(layers.Dense(     <span class="comment"># 添加带有 relu 激活函数的全连接层</span></span><br><span class="line">                         units=<span class="number">128</span>, </span><br><span class="line">                         activation=<span class="string">'relu'</span></span><br><span class="line">                         ))</span><br><span class="line">network.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line"><span class="comment"># network.add(layers.Dropout(0.4))</span></span><br><span class="line"><span class="comment"># 最后一层必须有并且一定是 [输出层], 必选                         </span></span><br><span class="line">network.add(layers.Dense(     <span class="comment"># 添加带有 softmax 激活函数的全连接层</span></span><br><span class="line">                         units=<span class="number">8</span>,</span><br><span class="line">                         activation=<span class="string">'sigmoid'</span></span><br><span class="line">                         ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 3 编译神经网络</span></span><br><span class="line">network.compile(loss=<span class="string">'categorical_crossentropy'</span>,  <span class="comment"># 分类交叉熵损失函数    </span></span><br><span class="line">                optimizer=<span class="string">'rmsprop'</span>,  </span><br><span class="line">                metrics=[<span class="string">'accuracy'</span>]              <span class="comment"># 准确率度量</span></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 4 开始训练神经网络</span></span><br><span class="line">history = network.fit(X_train_count,     <span class="comment"># 训练集特征</span></span><br><span class="line">            y_train_cate,        <span class="comment"># 训练集标签</span></span><br><span class="line">            epochs=<span class="number">20</span>,          <span class="comment"># 迭代次数</span></span><br><span class="line">            batch_size=<span class="number">300</span>,    <span class="comment"># 每个批量的观测数  可做优化</span></span><br><span class="line">            validation_data=(X_test_count, y_test_cate)  <span class="comment"># 验证测试集数据</span></span><br><span class="line">            )</span><br><span class="line">network.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 6 性能评估</span></span><br><span class="line">print(<span class="string">'&gt;&gt;&gt;多分类前馈神经网络性能评估如下...\n'</span>)</span><br><span class="line">score = network.evaluate(X_test_count,</span><br><span class="line">                        y_test_cate,</span><br><span class="line">                        batch_size=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n&gt;&gt;&gt;评分\n'</span>, score)</span><br><span class="line">print()</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line">estimator_list.append(<span class="string">'前馈网络'</span>)</span><br><span class="line">score_list.append(score[<span class="number">1</span>])</span><br><span class="line">time_list.append(round(end-start, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="../../2020/02/12/NLP入门之文本分类/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="../../"><i class="fas fa-angle-left"></i></a><a class="page-number" href="../../">1</a><span class="page-number current">2</span><a class="page-number" href="../3/">3</a><a class="page-number" href="../4/">4</a><a class="extend next" rel="next" href="../3/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Rr-shan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="../../js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>