<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="srf之论文阅读Dr.VAE"><meta name="keywords" content><meta name="author" content="Rr-shan,undefined"><meta name="copyright" content="Rr-shan"><title>srf之论文阅读Dr.VAE【Sanzzi】</title><link rel="stylesheet" href="../../../../css/fan.css"><link rel="stylesheet" href="../../../../css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="../../../../favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="../../../../js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Dr-VAE-improving-drug-response-prediction-via-modeling-of-drug-perturbation-effects"><span class="toc-number">1.</span> <span class="toc-text">Dr.VAE: improving drug response prediction via modeling of drug perturbation effects</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-为什么要讲这个"><span class="toc-number">1.1.</span> <span class="toc-text">1. 为什么要讲这个?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-提出了什么方法"><span class="toc-number">1.2.</span> <span class="toc-text">2. 提出了什么方法 ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-传统方法有什么问题-（对比）"><span class="toc-number">1.3.</span> <span class="toc-text">3. 传统方法有什么问题?（对比）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）"><span class="toc-number">1.4.</span> <span class="toc-text">4. 原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-数据集是怎么划分的"><span class="toc-number">1.5.</span> <span class="toc-text">5. 数据集是怎么划分的?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两个数据集的基本介绍："><span class="toc-number">1.5.1.</span> <span class="toc-text">两个数据集的基本介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实验数据选择标准："><span class="toc-number">1.5.2.</span> <span class="toc-text">实验数据选择标准：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-交叉验证怎么做"><span class="toc-number">1.6.</span> <span class="toc-text">7. 交叉验证怎么做?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Discussion："><span class="toc-number">1.7.</span> <span class="toc-text">8. Discussion：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#局限性："><span class="toc-number">1.7.1.</span> <span class="toc-text">局限性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预备-amp-补充知识："><span class="toc-number">1.8.</span> <span class="toc-text">预备&amp;补充知识：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是VAE-Variational-auto-encoder、变分自编码器-？"><span class="toc-number">1.8.1.</span> <span class="toc-text">什么是VAE(Variational auto-encoder、变分自编码器)？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VAE有什么用？"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">VAE有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VAE网络结构组成："><span class="toc-number">1.8.1.2.</span> <span class="toc-text">VAE网络结构组成：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ablation-study消融实验"><span class="toc-number">1.8.2.</span> <span class="toc-text">ablation study消融实验:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考："><span class="toc-number">1.8.3.</span> <span class="toc-text">参考：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文章："><span class="toc-number">1.8.3.1.</span> <span class="toc-text">文章：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#视频："><span class="toc-number">1.8.3.2.</span> <span class="toc-text">视频：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Rr-shan</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Rr-shan" target="_blank">GitHub<i class="icon-dot bg-color0"></i></a><a class="links-button button-hover" href="mailto:1224559633@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="www.sanzzi.cn" target="_blank">Mywebsite<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="../../../../archives"><span class="pull-top">日志</span><span class="pull-bottom">29</span></a><a class="author-info-articles-tags article-meta" href="../../../../tags"><span class="pull-top">标签</span><span class="pull-bottom">2</span></a></div><div class="friend-link"><a class="friend-link-text" href="https://chao-yin-github.github.io/" target="_blank">yccccc~~~~~~~~</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Sanzzi</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">srf之论文阅读Dr.VAE</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-04-01 | 更新于 2020-04-01</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"></div></div></div><div class="main-content"><h1 id="Dr-VAE-improving-drug-response-prediction-via-modeling-of-drug-perturbation-effects"><a href="#Dr-VAE-improving-drug-response-prediction-via-modeling-of-drug-perturbation-effects" class="headerlink" title="Dr.VAE: improving drug response prediction via modeling of drug perturbation effects"></a>Dr.VAE: improving drug response prediction via modeling of drug perturbation effects</h1><h2 id="1-为什么要讲这个"><a href="#1-为什么要讲这个" class="headerlink" title="1. 为什么要讲这个?"></a>1. 为什么要讲这个?</h2><p><strong>Motivation:</strong><br>将<strong>生物逻辑系统的先验知识</strong>融入到这些方法中是<strong>提高预测性能</strong>的一个很有前途的途径。<br><strong>药物诱导转录组微扰效应的高通量细胞系分析</strong>(High-throughput cell line assays of drug-induced transcriptomic perturbation effects)是一项尚未完全纳入药物反应预测模型的先验知识。</p>
<h2 id="2-提出了什么方法"><a href="#2-提出了什么方法" class="headerlink" title="2. 提出了什么方法 ?"></a>2. 提出了什么方法 ?</h2><p>引入了一个统一的<strong>概率方法</strong>，<strong>Dr.VAE</strong>(Drug Response Variational Autoencoder、药物反应变分自动编码器），它同时根据<strong>活性</strong>和<strong>转录组的扰动</strong>来模拟药物反应。<del>翻译怪怪的??</del> </p>
<p>已知：</p>
<ol>
<li>VAE可以提取出具有生物学意义的癌症经切切片特征</li>
<li>在一种名为DeepProfile的药物反应预测方法中，将预先训练的VAE和单独训练的线性模型相结合。<br>我们旨在共同学习一种潜在的嵌入方法，以提高我们预测药物反应（表型结果）的能力，同时利用最初不受监督的（未知表型结果）药物每次扰动实验来帮助学习这种嵌入方法。</li>
</ol>
<p>放模型图！</p>
<h2 id="3-传统方法有什么问题-（对比）"><a href="#3-传统方法有什么问题-（对比）" class="headerlink" title="3. 传统方法有什么问题?（对比）"></a>3. 传统方法有什么问题?（对比）</h2><p>现有的机器学习算法：<br>深度学习的方法：典型的判别前馈神经网络在药物反应预测中效果不佳，很可能是由于数据限制（特征数量与样本数量）所致。</p>
<p>Result部分<br><em>代码体现</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classif_baseline_perf</span><span class="params">(xtrain, ytrain, xtest, ytest, svmkernel=<span class="string">'rbf'</span>, rseed=None)</span>:</span></span><br><span class="line">    <span class="string">'''这个包括了和 Random Forest、LogisticRegression、SVM、SVM w/ linear kernel的对比'''</span></span><br><span class="line">    data = [xtrain, ytrain, xtest, ytest]</span><br><span class="line">    perf = OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## Random Forest</span></span><br><span class="line">    cl = sklearn.ensemble.RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=rseed)</span><br><span class="line">    rf_perf = measure_cl_perf(cl, <span class="string">'RF100'</span>, *data)</span><br><span class="line">    perf = concat_dicts(perf, rf_perf)</span><br><span class="line"></span><br><span class="line">	<span class="comment">## LogisticRegression</span></span><br><span class="line">    cl = sklearn.linear_model.LogisticRegressionCV(penalty=<span class="string">'l2'</span>, random_state=rseed)</span><br><span class="line">    lr_perf = measure_cl_perf(cl, <span class="string">'Ridge'</span>, *data)</span><br><span class="line">    perf = concat_dicts(perf, lr_perf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## SVM </span></span><br><span class="line">    cl = sklearn.svm.SVC(kernel=svmkernel, probability=<span class="literal">True</span>, random_state=rseed)</span><br><span class="line">    svm_perf = measure_cl_perf(cl, <span class="string">'SVM'</span> + svmkernel[:<span class="number">3</span>], *data)</span><br><span class="line">    perf = concat_dicts(perf, svm_perf)</span><br><span class="line">    <span class="comment"># SVM w/ linear kernel</span></span><br><span class="line">    cl = sklearn.svm.SVC(kernel=<span class="string">'linear'</span>, probability=<span class="literal">True</span>, random_state=rseed)</span><br><span class="line">    svm_perf = measure_cl_perf(cl, <span class="string">'SVMlin'</span>, *data)</span><br><span class="line">    perf = concat_dicts(perf, svm_perf)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> perf</span><br></pre></td></tr></table></figure>

<p>measure_cl_perf()函数作用是评估，计算出的是Acc、AUROC、AUPR<br>concat_dicts()转化为字典</p>
<h2 id="4-原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）"><a href="#4-原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）" class="headerlink" title="4. 原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）?"></a>4. 原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）?</h2><h2 id="5-数据集是怎么划分的"><a href="#5-数据集是怎么划分的" class="headerlink" title="5. 数据集是怎么划分的?"></a>5. 数据集是怎么划分的?</h2><blockquote>
<p><strong>Training data sets</strong>：<strong>CTRPv2</strong>( Cancer Therapeutic Response Portal)  &amp;  <strong>CMap</strong> (CMap-L1000v1)<br><strong>Input data types</strong>：<strong>mRNA</strong> EXP (before &amp; after treatment)</p>
</blockquote>
<h3 id="两个数据集的基本介绍："><a href="#两个数据集的基本介绍：" class="headerlink" title="两个数据集的基本介绍："></a>两个数据集的基本介绍：</h3><p><strong>CTRPv2</strong>：为860个细胞系和481个药物化合物的组合<strong>提供了不同药物浓度下细胞系的相对生存能力</strong>。细胞系对<strong>药物治疗的敏感性</strong>通过<strong>剂量-反应曲线AAC</strong>上方的面积来量化，我们进一步采用瀑布法对连续的AAC进行二值化（Barretina等人，2012；Haibe-Kains等人，2013），<strong>将灵敏度预测任务转化为离散的分类任务。</strong>  <del>体现在哪里？</del><br><strong>CMap</strong>：筛选了19 811种药物化合物对多达77个细胞系中L1000个标志性基因表达的干扰效应。<br>在CMap中的实验并<strong>不能测量药物治疗的敏感性</strong>，但是一些细胞系也在CTRPv2中进行了独立的测试。我们<strong>交叉</strong>引用这些细胞系(取交集)，并将相应的标签分配给它们的扰动测量。</p>
<h3 id="实验数据选择标准："><a href="#实验数据选择标准：" class="headerlink" title="实验数据选择标准："></a>实验数据选择标准：</h3><ol>
<li>从CMap数据集，选择了在<strong>最常见浓度水平下对每种药物进行6小时的微扰实验</strong>。如果细胞系没有在选定的浓度下进行检测，我们使用最接近的检测浓度。接下来，我们将对照组（DMSO载体）实验与药物扰动实验通过批次ID和微珠ID进行匹配，以最小化病例和对照组之间的批次效应。<del>？？</del> 此外，我们通过相关性（&gt;0.75 Pearson q）过滤所选的病例对照对，以过滤出可能标记错误的实验或异常值。</li>
<li>CTRPv2和CMap-L1000v1数据集共有<strong>973</strong>个共同基因。将<strong>每个基因的表达值标准化为零均值和单位方差</strong>。为了进一步的均匀化，包括去除批效应和两个合并数据之间的差异，我们还从集合数据集中去除了第一个主成分（解释了12.8%的变化）。<br>叨叨：数据的筛选真的太讲究了<br>基于以上两个标准，我们选择了<strong>26</strong>种在CTRPv2和CMap-L1000v1数据集中测试的<strong>药物</strong>：</li>
</ol>
<ul>
<li>对于每种选择的药物，至少有<strong>8个不同的细胞系在CMap干扰实验中测试。</strong></li>
<li>CTRPv2中至少有20%的筛选细胞系在剂量-反应AAC二值化后<strong>对药物敏感</strong>。</li>
</ul>
<p><del>插图</del> </p>
<h2 id="7-交叉验证怎么做"><a href="#7-交叉验证怎么做" class="headerlink" title="7. 交叉验证怎么做?"></a>7. 交叉验证怎么做?</h2><p>通过执行20次重复的<strong>5倍交叉验证</strong>，我们生成了100个训练验证测试数据拆分。<br><em>代码体现</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSplitsByGroupKFold</span><span class="params">(groups, fold, n_splits, shuffle, random_state)</span>:</span></span><br><span class="line">    <span class="string">'''the same group will not appear in two different folds'''</span></span><br><span class="line">    <span class="keyword">assert</span> (n_splits &gt;= <span class="number">3</span>)</span><br><span class="line">    kf = GroupKFold(n_splits=n_splits)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> shuffle:</span><br><span class="line">        <span class="comment"># randomly rename groups so that the GroupKFold (which sorts by group ids first) splits can be randomized</span></span><br><span class="line">        unique_groups = np.unique(groups)</span><br><span class="line">        rnd_renames = sklearn.utils.shuffle(np.arange(len(unique_groups)), random_state=random_state)</span><br><span class="line">        groups_renamed = np.array([rnd_renames[np.argwhere(unique_groups == g)[<span class="number">0</span>]] <span class="keyword">for</span> g <span class="keyword">in</span> groups])</span><br><span class="line">        kfsplit = kf.split(X=np.zeros(groups.shape[<span class="number">0</span>]), groups=groups_renamed)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        kfsplit = kf.split(X=np.zeros(groups.shape[<span class="number">0</span>]), groups=groups)</span><br><span class="line">    allsplits = np.array([x <span class="keyword">for</span> x <span class="keyword">in</span> kfsplit])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(fold, list) <span class="keyword">or</span> isinstance(fold, tuple):</span><br><span class="line">        <span class="keyword">assert</span> (len(fold) == <span class="number">2</span>)</span><br><span class="line">        te_fold = fold[<span class="number">0</span>]</span><br><span class="line">        va_fold = fold[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        te_fold = fold</span><br><span class="line">        va_fold = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> (te_fold &gt;= <span class="number">1</span> <span class="keyword">and</span> te_fold &lt;= n_splits)      <span class="comment">## the test fold is between 1..n_splits</span></span><br><span class="line">    <span class="keyword">assert</span> (va_fold &gt;= <span class="number">1</span> <span class="keyword">and</span> va_fold &lt;= n_splits - <span class="number">1</span>)  <span class="comment">## the validation fold is between 1..(n_splits-1)</span></span><br><span class="line">    <span class="comment"># the te_fold is indexed from 1 so we need to subtract 1</span></span><br><span class="line">    te_fold_id = te_fold - <span class="number">1</span></span><br><span class="line">    va_fold_id = (te_fold_id + va_fold) % n_splits</span><br><span class="line">    ind_te = allsplits[te_fold_id][<span class="number">1</span>]</span><br><span class="line">    ind_va = allsplits[va_fold_id][<span class="number">1</span>]</span><br><span class="line">    ind_tr = np.concatenate(allsplits[np.setdiff1d(np.arange(n_splits), np.asarray([te_fold_id, va_fold_id]))][:, <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">assert</span> (checkSplit(ind_tr, ind_va, ind_te))</span><br><span class="line">    <span class="keyword">return</span> ind_tr, ind_va, ind_te</span><br></pre></td></tr></table></figure>

<h2 id="8-Discussion："><a href="#8-Discussion：" class="headerlink" title="8. Discussion："></a>8. Discussion：</h2><p>典型的判别前馈神经网络在药物反应预测中效果不佳，很可能是由于数据限制（特征数量与样本数量）所致。 我们表明，<strong>药物反应和扰动效应的联合生成模型</strong>在很大程度上缓解了这种情况，<strong>可能起到了有效的正则化和鲁棒的特征提取的作用</strong>，而不会产生过拟合的情况。</p>
<h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h3><ol>
<li>只考虑基因表达方式，<strong>没有额外整合</strong>甲基化、拷贝数变化、相互作用状态的<strong>多组预测因子。</strong></li>
<li>我们在每种药物最常见的浓度水平下，对治疗6小时后的CMap-L1000v1扰动进行建模。有人认为，<strong>6小时太短，许多反馈调节机制无法体现自己，因此这些实验本身并不能提供完整的转录反应图片</strong>。值得注意的是，药物细胞系活力测定通常在较长的治疗时间（如72小时）内完成。因此，我们也用24小时的微扰实验来训练我们的VAE博士，然而，<strong>由于这样的实验数量有限</strong>，这并没有提高我们的预测性能。</li>
<li>Dr.VAE所组成的每一个条件分布都是由一个神经网络参数化的。调整超参数以匹配数据复杂性的能力使Dr.VAE成为一个非常灵活的模型。<strong>由于我们选择了简单性，我们的神经网络大多有一个隐藏层，而分类后验函数和扰动函数是线性的。</strong> 然而，到目前为止，我们试图通过更复杂的分布使用更深的网络或使用规范化流来近似后验的尝试，<strong>并没有显著地提高性能来证明增加的复杂性。</strong></li>
</ol>
<hr>
<h2 id="预备-amp-补充知识："><a href="#预备-amp-补充知识：" class="headerlink" title="预备&amp;补充知识："></a>预备&amp;补充知识：</h2><h3 id="什么是VAE-Variational-auto-encoder、变分自编码器-？"><a href="#什么是VAE-Variational-auto-encoder、变分自编码器-？" class="headerlink" title="什么是VAE(Variational auto-encoder、变分自编码器)？"></a>什么是VAE(Variational auto-encoder、变分自编码器)？</h3><p>一个可以和GAN相媲美的生成网络。<br>VAE通过说我希望生成一张新的猫脸，那么这个n维向量代表的就是n个决定最终猫脸模样的隐形因素。对于每个因素，都对应产生一种分布，从这些分布关系中进行采样，那么我就可以通过一个深度网络恢复出最终的猫脸。<br>通过一个网络，将一个高维空间的人脸映射为低维空间的一个向量。那么如果我将这个向量定义为四维，采用one-hot的表达方式表达四张不同的脸，那么这个网络就可以表达四个脸，你输入不同的数据，他就会输出不同的脸来。</p>
<h4 id="VAE有什么用？"><a href="#VAE有什么用？" class="headerlink" title="VAE有什么用？"></a>VAE有什么用？</h4><p>VAE到底有什么用呢，就为了把大量的数据存储到网络结构中去呀，当然不能是这么简单的一个事。想象一下，在一个末日大片中，我们需要去搞出一个许多机器人占领世界的场面，但是我们的特效师一张张去画，这无疑会是一个令人头疼的工作，利用VAE，只需要使用有限的数据输入，我们就可以通过隐形参数的调节，获得几乎无限的数量。</p>
<h4 id="VAE网络结构组成："><a href="#VAE网络结构组成：" class="headerlink" title="VAE网络结构组成："></a>VAE网络结构组成：</h4><p>可以大致分成<strong>Encoder</strong>和<strong>Decoder</strong>两部分。对于输入图片，Encoder将提取得到编码：一个<strong>mean vector</strong>（均值）和一个<strong>deviation vector</strong>（方差），然后将这个编码（两个vector）作为Decoder的输入，最终输出一张和原图相近的图片。</p>
<p>它本质上就是在我们常规的自编码器的基础上，对 encoder 的结果（在VAE中对应着计算均值的网络）加上了<strong>“高斯噪声”</strong>，使得结果 decoder 能够对噪声有鲁棒性；而那个额外的 KL loss（目的是让均值为 0，方差为 1），事实上就是相当于对 encoder 的一个正则项，希望 encoder 出来的东西均有零均值。</p>
<p>drug perturbation effects是什么?</p>
<h3 id="ablation-study消融实验"><a href="#ablation-study消融实验" class="headerlink" title="ablation study消融实验:"></a>ablation study消融实验:</h3><p>论证是什么起了作用，类似于中学学的控制变量<br>模型简化测试。<br>看看取消掉一些模块后性能有没有影响。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><h4 id="文章："><a href="#文章：" class="headerlink" title="文章："></a>文章：</h4><p><a href="https://blog.csdn.net/weixin_40955254/article/details/82315224" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40955254/article/details/82315224</a><br><a href="https://blog.csdn.net/cjh_jinduoxia/article/details/84995156" target="_blank" rel="noopener">https://blog.csdn.net/cjh_jinduoxia/article/details/84995156</a></p>
<h4 id="视频："><a href="#视频：" class="headerlink" title="视频："></a>视频：</h4><p>（白板推导）<a href="https://www.bilibili.com/video/BV15E411w7Pz" target="_blank" rel="noopener">https://www.bilibili.com/video/BV15E411w7Pz</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rr-shan</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://rr-shan.github.io/2020/04/01/srf之论文阅读Dr.VAE/">https://rr-shan.github.io/2020/04/01/srf之论文阅读Dr.VAE/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rr-shan.github.io">Sanzzi</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="../../../03/29/srf之论文汇报流程/"><span>srf之论文汇报流程</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Rr-shan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>