<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java垃圾回收机制"><meta name="keywords" content="Java"><meta name="author" content="Rr-shan,undefined"><meta name="copyright" content="Rr-shan"><title>Java垃圾回收机制【Sanzzi】</title><link rel="stylesheet" href="../../../../css/fan.css"><link rel="stylesheet" href="../../../../css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="../../../../favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="../../../../js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java垃圾回收机制"><span class="toc-number">1.</span> <span class="toc-text">Java垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收的意义"><span class="toc-number">1.1.</span> <span class="toc-text">垃圾回收的意义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#这使Java-虚拟机具有一些优点"><span class="toc-number">1.1.1.</span> <span class="toc-text">这使Java 虚拟机具有一些优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收的一个潜在的缺点是它的开销影响程序性能。"><span class="toc-number">1.1.2.</span> <span class="toc-text">垃圾回收的一个潜在的缺点是它的开销影响程序性能。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集的算法分析"><span class="toc-number">1.2.</span> <span class="toc-text">垃圾收集的算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-引用计数法-Reference-Counting-Collector"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 引用计数法(Reference Counting Collector)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点："><span class="toc-number">1.2.1.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点："><span class="toc-number">1.2.1.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-tracing算法-Tracing-Collector"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. tracing算法(Tracing Collector)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-compacting算法-Compacting-Collector"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. compacting算法(Compacting Collector)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-copying（复制）算法-Coping-Collector"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. copying（复制）算法(Coping Collector)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点：-1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点：-1"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-generation（分代收集）算法-Generational-Collector"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. generation（分代收集）算法(Generational Collector)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-adaptive算法-Adaptive-Collector"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. adaptive算法(Adaptive Collector)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-gc-方法"><span class="toc-number">1.3.</span> <span class="toc-text">System.gc()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finalize-方法"><span class="toc-number">1.4.</span> <span class="toc-text">finalize()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#触发主GC（Garbage-Collector）的条件"><span class="toc-number">1.5.</span> <span class="toc-text">触发主GC（Garbage Collector）的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#减少GC开销的措施"><span class="toc-number">1.6.</span> <span class="toc-text">减少GC开销的措施</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-不要显式调用System-gc"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 不要显式调用System.gc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-尽量减少临时对象的使用"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 尽量减少临时对象的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-对象不用时最好显式置为Null"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 对象不用时最好显式置为Null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-尽量使用StringBuffer-而不用String来累加字符串"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 尽量使用StringBuffer,而不用String来累加字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-能用基本类型如Int-Long-就不用Integer-Long对象"><span class="toc-number">1.6.5.</span> <span class="toc-text">5.  能用基本类型如Int,Long,就不用Integer,Long对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-尽量少用静态对象变量"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. 尽量少用静态对象变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-分散对象创建或删除的时间"><span class="toc-number">1.6.7.</span> <span class="toc-text">7. 分散对象创建或删除的时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于垃圾回收的几点补充"><span class="toc-number">1.7.</span> <span class="toc-text">关于垃圾回收的几点补充</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Rr-shan</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Rr-shan" target="_blank">GitHub<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="mailto:1224559633@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color1"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="../../../../archives"><span class="pull-top">日志</span><span class="pull-bottom">40</span></a><a class="author-info-articles-tags article-meta" href="../../../../tags"><span class="pull-top">标签</span><span class="pull-bottom">11</span></a><a class="author-info-articles-categories article-meta" href="../../../../categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="https://chao-yin-github.github.io/" target="_blank">yccccc~~~~~~~~</a><a class="friend-link-text" href="https://sanzzi.cn" target="_blank">Mywebsite</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Sanzzi</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Java垃圾回收机制</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-02-20 | 更新于 2020-04-03</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="../../../../tags/Java/">Java</a></div></div></div><div class="main-content"><h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><h2 id="垃圾回收的意义"><a href="#垃圾回收的意义" class="headerlink" title="垃圾回收的意义"></a>垃圾回收的意义</h2><p>在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。<br>事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。</p>
<h3 id="这使Java-虚拟机具有一些优点"><a href="#这使Java-虚拟机具有一些优点" class="headerlink" title="这使Java 虚拟机具有一些优点"></a>这使Java 虚拟机具有一些优点</h3><ul>
<li>首先，它能<strong>使编程效率提高</strong>。在没有垃圾回收机制的时候，可能要花许多时间来解决一个<strong>难懂的存储器问题。</strong></li>
<li>其次是它<strong>保护程序的完整性</strong>（？）， 垃圾回收是Java语言安全性策略的一个重要部份。</li>
</ul>
<h3 id="垃圾回收的一个潜在的缺点是它的开销影响程序性能。"><a href="#垃圾回收的一个潜在的缺点是它的开销影响程序性能。" class="headerlink" title="垃圾回收的一个潜在的缺点是它的开销影响程序性能。"></a>垃圾回收的一个潜在的缺点是它的<strong>开销影响程序性能</strong>。</h3><ul>
<li>Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要<strong>花费处理器的时间。</strong></li>
<li>其次<strong>垃圾回收算法的不完备性</strong>，<em>早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。</em>随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。</li>
</ul>
<h2 id="垃圾收集的算法分析"><a href="#垃圾收集的算法分析" class="headerlink" title="垃圾收集的算法分析"></a>垃圾收集的算法分析</h2><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：<br>**1. 发现无用信息对象</p>
<ol start="2">
<li>回收被无用对象占用的内存空间，使该空间可被程序再次使用。**</li>
</ol>
<blockquote>
<p>大多数垃圾回收算法使用了<strong>根集(root set)</strong>这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃圾回收首先需要确定从根开始 <strong>哪些是可达的和哪些是不可达的</strong>，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。</p>
</blockquote>
<h3 id="1-引用计数法-Reference-Counting-Collector"><a href="#1-引用计数法-Reference-Counting-Collector" class="headerlink" title="1. 引用计数法(Reference Counting Collector)"></a>1. 引用计数法(Reference Counting Collector)</h3><p>引用计数法是<strong>唯一没有使用根集的</strong>垃圾回收的算法，该算法使用引用计数器来区分存活对象和不再使用的对象。堆中的每个对象对应一个引用计数器。<em>计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。</em><br>引用计数算法实现简单，效率很高，微软的COM技术、ActionScript、Python等都使用了引用计数算法进行内存管理，但是引用计数算法对于对象之间相互循环引用问题难以解决，因此java并没有使用引用计数算法。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>基于引用计数器的垃圾收集器运行较<strong>快</strong>，<em>对程序需要不被长时间打断的实时环境比较有利。</em></p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p> <strong>无法检测出循环引用</strong>如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0. 而且每次加减<strong>非常浪费内存</strong>。</p>
<h3 id="2-tracing算法-Tracing-Collector"><a href="#2-tracing算法-Tracing-Collector" class="headerlink" title="2. tracing算法(Tracing Collector)"></a>2. tracing算法(Tracing Collector)</h3><p>tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.</p>
<h3 id="3-compacting算法-Compacting-Collector"><a href="#3-compacting算法-Compacting-Collector" class="headerlink" title="3. compacting算法(Compacting Collector)"></a>3. compacting算法(Compacting Collector)</h3><p>为了<strong>解决堆碎片问题</strong>，基于tracing的垃圾回收吸收了<strong>Compacting算法</strong>的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加<strong>句柄和句柄表</strong>。</p>
<p>标记-整理算法在标记-清除算法基础上做了改进，标记阶段是相同的标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。<br>标记-整理算法相比标记-清除算法的优点是内存<strong>被整理以后不会产生大量不连续内存碎片问题。</strong><br>复制算法在<strong>对象存活率高的情况下</strong>就要执行较多的复制操作，效率将会变低，而在对象存活率高的情况下使用标记-整理算法效率会大大提高。</p>
<h3 id="4-copying（复制）算法-Coping-Collector"><a href="#4-copying（复制）算法-Coping-Collector" class="headerlink" title="4. copying（复制）算法(Coping Collector)"></a>4. copying（复制）算法(Coping Collector)</h3><p>该算法的提出是为了<strong>克服句柄的开销和解决堆碎片的垃圾回收</strong>。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。<br>一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，在对象区与空闲区域的切换过程中，程序暂停执行。</p>
<p>S0和s1将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>可使用的内存降为原来一半。</p>
<p>复制算法用于在<strong>新生代垃圾回收</strong></p>
<h3 id="5-generation（分代收集）算法-Generational-Collector"><a href="#5-generation（分代收集）算法-Generational-Collector" class="headerlink" title="5. generation（分代收集）算法(Generational Collector)"></a>5. generation（分代收集）算法(Generational Collector)</h3><p>stop-and-copy垃圾收集器的一个缺陷是<strong>收集器必须复制所有的活动对象</strong>，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代(generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。</p>
<p>根据内存中对象的存活周期不同，将内存划分为几块，java的虚拟机中一般把内存划分为新生代和年老代，当新创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中，当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。<br>对于新生代和老年代来说,新生代回收频率很高,但是每次回收耗时很短,而老年代回收频率较低,但是耗时会相对较长,所以应该尽量减少老年代的GC.</p>
<h3 id="6-adaptive算法-Adaptive-Collector"><a href="#6-adaptive算法-Adaptive-Collector" class="headerlink" title="6. adaptive算法(Adaptive Collector)"></a>6. adaptive算法(Adaptive Collector)</h3><p>　　在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p>
<h2 id="System-gc-方法"><a href="#System-gc-方法" class="headerlink" title="System.gc()方法"></a>System.gc()方法</h2><p>使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestGC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">　　    <span class="keyword">new</span> TestGC();</span><br><span class="line">　　    System.gc();</span><br><span class="line">　　    System.runFinalization();</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips:调用System.gc()也仅仅是一个<strong>请求(建议)</strong>。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。</p>
<h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h2><p>之所以要使用finalize()，是存在着<strong>垃圾回收器不能处理的特殊情况</strong>。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。</p>
<p>特殊的区域如：</p>
<ol>
<li>由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。</li>
<li>又或者打开的<strong>文件资源</strong>，这些资源不属于垃圾回收器的回收范围。</li>
</ol>
<h2 id="触发主GC（Garbage-Collector）的条件"><a href="#触发主GC（Garbage-Collector）的条件" class="headerlink" title="触发主GC（Garbage Collector）的条件"></a>触发主GC（Garbage Collector）的条件</h2><p>JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。<br>总的来说,有两个条件会触发主GC:</p>
<ol>
<li>当<strong>没有应用线程在运行时</strong>,GC会被调用。因为<strong>GC在优先级最低的线程中进行</strong>,所以当应用忙时,GC线程就不会被调用,但以下条件除外。</li>
<li><strong>Java堆内存不足时</strong>,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,<strong>JVM会再进行两次GC</strong>作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。</li>
</ol>
<h2 id="减少GC开销的措施"><a href="#减少GC开销的措施" class="headerlink" title="减少GC开销的措施"></a>减少GC开销的措施</h2><h3 id="1-不要显式调用System-gc"><a href="#1-不要显式调用System-gc" class="headerlink" title="1. 不要显式调用System.gc()"></a>1. 不要显式调用System.gc()</h3><p> 此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</p>
<h3 id="2-尽量减少临时对象的使用"><a href="#2-尽量减少临时对象的使用" class="headerlink" title="2. 尽量减少临时对象的使用"></a>2. 尽量减少临时对象的使用</h3><p> 临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</p>
<h3 id="3-对象不用时最好显式置为Null"><a href="#3-对象不用时最好显式置为Null" class="headerlink" title="3. 对象不用时最好显式置为Null"></a>3. 对象不用时最好显式置为Null</h3><p> 为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</p>
<h3 id="4-尽量使用StringBuffer-而不用String来累加字符串"><a href="#4-尽量使用StringBuffer-而不用String来累加字符串" class="headerlink" title="4. 尽量使用StringBuffer,而不用String来累加字符串"></a>4. 尽量使用StringBuffer,而不用String来累加字符串</h3><p>  由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</p>
<h3 id="5-能用基本类型如Int-Long-就不用Integer-Long对象"><a href="#5-能用基本类型如Int-Long-就不用Integer-Long对象" class="headerlink" title="5.  能用基本类型如Int,Long,就不用Integer,Long对象"></a>5.  能用基本类型如Int,Long,就不用Integer,Long对象</h3><p>基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</p>
<h3 id="6-尽量少用静态对象变量"><a href="#6-尽量少用静态对象变量" class="headerlink" title="6. 尽量少用静态对象变量"></a>6. 尽量少用静态对象变量</h3><p>静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</p>
<h3 id="7-分散对象创建或删除的时间"><a href="#7-分散对象创建或删除的时间" class="headerlink" title="7. 分散对象创建或删除的时间"></a>7. 分散对象创建或删除的时间</h3><p>集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chair</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">boolean</span> gcrun = <span class="keyword">false</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">boolean</span> f = <span class="keyword">false</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">int</span> created = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">int</span> finalized = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">　　Chair() &#123;</span><br><span class="line">　　    i = ++created;</span><br><span class="line">　　    <span class="keyword">if</span>(created == <span class="number">47</span>)</span><br><span class="line">　　　      System.out.println(<span class="string">"Created 47"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　    <span class="keyword">if</span>(!gcrun) &#123;</span><br><span class="line">　　　      gcrun = <span class="keyword">true</span>;</span><br><span class="line">　　　      System.out.println(<span class="string">"Beginning to finalize after "</span> + created + <span class="string">" Chairs have been created"</span>);</span><br><span class="line">　　    &#125;</span><br><span class="line">　　    <span class="keyword">if</span>(i == <span class="number">47</span>) &#123;</span><br><span class="line">　　　      System.out.println(<span class="string">"Finalizing Chair #47， "</span> +<span class="string">"Setting flag to stop Chair creation"</span>);</span><br><span class="line">　　　      f = <span class="keyword">true</span>;</span><br><span class="line">　　    &#125;</span><br><span class="line">　　    finalized++;</span><br><span class="line">　　    <span class="keyword">if</span>(finalized &gt;= created)</span><br><span class="line">　　　      System.out.println(<span class="string">"All "</span> + finalized + <span class="string">" finalized"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Garbage</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span>(args.length == <span class="number">0</span>) &#123;</span><br><span class="line">　　　  System.err.println(<span class="string">"Usage: /n"</span> + <span class="string">"java Garbage before/n or:/n"</span> + <span class="string">"java Garbage after"</span>);</span><br><span class="line">　　　  <span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">while</span>(!Chair.f) &#123;</span><br><span class="line">　　　  <span class="keyword">new</span> Chair();</span><br><span class="line">　　　  <span class="keyword">new</span> String(<span class="string">"To take up space"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　System.out.println(<span class="string">"After all Chairs have been created:/n"</span> + <span class="string">"total created = "</span> + Chair.created +</span><br><span class="line">　　<span class="string">"， total finalized = "</span> + Chair.finalized);</span><br><span class="line">　　<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"before"</span>)) &#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"gc():"</span>);</span><br><span class="line">　　　　System.gc();</span><br><span class="line">　　　　System.out.println(<span class="string">"runFinalization():"</span>);</span><br><span class="line">　　　　System.runFinalization();</span><br><span class="line">　　&#125;</span><br><span class="line">　　System.out.println(<span class="string">"bye!"</span>);</span><br><span class="line">　　<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"after"</span>))</span><br><span class="line">　　　  System.runFinalizersOnExit(<span class="keyword">true</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这个程序创建了许多Chair对象，而且在垃圾收集器开始运行后的某些时候，程序会停止创建Chair。由于垃圾收集器可能在任何时间运行，所以我们不能准确知道它在何时启动。因此，程序用一个名为gcrun的标记来指出垃圾收集器是否已经开始运行。利用第二个标记f，Chair可告诉main()它应停止对象的生成。这两个标记都是在finalize()内部设置的，它调用于垃圾收集期间。另两个static变量–created以及 finalized–分别用于跟踪已创建的对象数量以及垃圾收集器已进行完收尾工作的对象数量。最后，每个Chair都有它自己的（非 static）int i，所以能跟踪了解它具体的编号是多少。编号为47的Chair进行完收尾工作后，标记会设为true，最终结束Chair对象的创建过程。</p>
</blockquote>
<h2 id="关于垃圾回收的几点补充"><a href="#关于垃圾回收的几点补充" class="headerlink" title="关于垃圾回收的几点补充"></a>关于垃圾回收的几点补充</h2><ul>
<li>垃圾收集发生的<strong>不可预知性</strong>：由于实现了不同的垃圾回收算法和采用了不同的收集机制，所以它有可能是定时发生，有可能是当出现系统空闲CPU资源时发生，也有可能是和原始的垃圾收集一样，等到内存消耗出现极限时发生，这与垃圾收集器的选择和具体的设置都有关系。</li>
<li>垃圾收集的实现和<strong>具体的JVM 以及JVM的内存模型</strong>有非常紧密的关系。不同的JVM 可能采用不同的垃圾收集，而<strong>JVM 的内存模型决定着该JVM可以采用哪些类型垃圾收集</strong>。现在，<strong>HotSpot 系列</strong>JVM中的内存系统都采用先进的面向对象的框架设计，这使得该系列JVM都可以采用最先进的垃圾收集。</li>
<li><strong>尽早释放无用对象的引用。</strong>大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的<strong>对象是否被监听</strong>，如果有，则要<strong>去掉监听器，然后再赋空值</strong>。</li>
<li>关键的也是难把握的问题是<strong>内存泄漏</strong>。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。</li>
</ul>
<p>博客参考：<br><a href="https://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="noopener">https://blog.csdn.net/zsuguangh/article/details/6429592</a><br><a href="https://blog.csdn.net/zhangcongyi420/article/details/89060970" target="_blank" rel="noopener">https://blog.csdn.net/zhangcongyi420/article/details/89060970</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rr-shan</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://rr-shan.github.io/2020/02/20/Java垃圾回收机制/">https://rr-shan.github.io/2020/02/20/Java垃圾回收机制/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rr-shan.github.io">Sanzzi</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="../../22/解决IDEA和Pycharm中Vim插件不能与外界粘贴复制/"><i class="fas fa-angle-left">&nbsp;</i><span>解决IDEA和Pycharm中Vim插件不能与外界粘贴复制</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="../../19/leetcode数组类/"><span>leetcode之数组类</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Rr-shan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>