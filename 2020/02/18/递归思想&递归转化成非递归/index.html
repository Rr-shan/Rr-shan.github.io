<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="递归思想&amp;递归转化成非递归"><meta name="keywords" content="数据结构"><meta name="author" content="Rr-shan,undefined"><meta name="copyright" content="Rr-shan"><title>递归思想&amp;递归转化成非递归【Sanzzi】</title><link rel="stylesheet" href="../../../../css/fan.css"><link rel="stylesheet" href="../../../../css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="../../../../favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="../../../../js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#递归理解"><span class="toc-number">1.</span> <span class="toc-text">递归理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归、循环、迭代、遍历的区别"><span class="toc-number">2.</span> <span class="toc-text">递归、循环、迭代、遍历的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归过程初分析"><span class="toc-number">3.</span> <span class="toc-text">递归过程初分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归转非递归的方法"><span class="toc-number">4.</span> <span class="toc-text">递归转非递归的方法</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Rr-shan</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Rr-shan" target="_blank">GitHub<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="mailto:1224559633@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color9"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="../../../../archives"><span class="pull-top">日志</span><span class="pull-bottom">40</span></a><a class="author-info-articles-tags article-meta" href="../../../../tags"><span class="pull-top">标签</span><span class="pull-bottom">11</span></a><a class="author-info-articles-categories article-meta" href="../../../../categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="https://chao-yin-github.github.io/" target="_blank">yccccc~~~~~~~~</a><a class="friend-link-text" href="https://sanzzi.cn" target="_blank">Mywebsite</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Sanzzi</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">递归思想&amp;递归转化成非递归</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-02-18 | 更新于 2020-04-03</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="../../../../categories/数据结构/">数据结构</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="../../../../tags/数据结构/">数据结构</a></div></div></div><div class="main-content"><h2 id="递归理解"><a href="#递归理解" class="headerlink" title="递归理解"></a>递归理解</h2><p><em>递归思想</em>就是：<strong>把问题分解成规模更小，但和原问题有着相同解法的问题。</strong><br><em>典型的问题</em>有<strong>汉诺塔问题，斐波那契数列，二分查找问题，快速排序问题</strong>等。<br>其实像我们常见的<strong>分治法和动态规划法</strong>都是递归思想的经典应用。</p>
<p><strong>最关键的：</strong><br>存在一个能让递归调用退出的<strong>出口</strong>。</p>
<h2 id="递归、循环、迭代、遍历的区别"><a href="#递归、循环、迭代、遍历的区别" class="headerlink" title="递归、循环、迭代、遍历的区别"></a>递归、循环、迭代、遍历的区别</h2><ul>
<li>递归：一个函数反复调用自身的行为，特指函数本身；</li>
<li>循环：满足一定条件下，重复执行某些行为，如while结构；</li>
<li>迭代：按某种规则执行一个序列中的每一项，如for结构；</li>
<li>遍历：按某种规则访问图形结构中每一个节点，特指图形结构。</li>
</ul>
<h2 id="递归过程初分析"><a href="#递归过程初分析" class="headerlink" title="递归过程初分析"></a>递归过程初分析</h2><p>在大多数机器上，每次调用函数时大致要做三个工作：调用前先<strong>保存寄存器</strong>，并在返回时恢复；复制实参；程序必须转向一个新位置执行。<br>其中，具体要保存的内容包括：局部变量、形参、调用函数地址、返回值。那么，如果递归调用N次，就要分配N<em>局部变量、N</em>形参、N<em>调用函数地址、N</em>返回值。这势必是影响效率的。</p>
<h2 id="递归转非递归的方法"><a href="#递归转非递归的方法" class="headerlink" title="递归转非递归的方法"></a>递归转非递归的方法</h2><ol>
<li>第一种情况：<strong>递归转尾递归</strong>的问题，这类问题可以不借助堆栈结构将递归转化为循环结构。</li>
<li>第二种情况：借助堆栈将递归转化为非递归（PS：任何递归都可以借助堆栈转化成非递归，第一种情况严格意义上来说不能看做是一种情况）。<br>其中，第二种情况又可以进一步分为两种转化方法：<ol>
<li>第一种方法：<strong>借助堆栈模拟递归的执行过程。</strong>这种方法几乎是<strong>通用</strong>的方法，因为递归本身就是通过堆栈实现的，我们只要把递归函数调用的局部变量和相应的状态放入到一个栈结构中，在函数调用和返回时做好push和pop操作，就可以了（<strong>模拟快排</strong>的例子）。</li>
<li>第二种方法：借助堆栈的循环结构算法。这种方法常常适用于某些局部变量有依赖关系，且需要重复执行的场景，例如<strong>二叉树的遍历算法</strong>，就采用的这种方法。</li>
</ol>
</li>
</ol>
<p><em>延伸问题:</em><br>在斐波那契数列中，如果兔子永远不死，一直繁衍下去，则怎么解？很明显，这是个大数问题。</p>
<p>参考：<br><a href="https://www.cnblogs.com/bakari/p/5349383.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/5349383.html</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rr-shan</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://rr-shan.github.io/2020/02/18/递归思想&amp;递归转化成非递归/">https://rr-shan.github.io/2020/02/18/递归思想&amp;递归转化成非递归/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rr-shan.github.io">Sanzzi</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="../../19/leetcode数组类/"><i class="fas fa-angle-left">&nbsp;</i><span>leetcode之数组类</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="../../17/pandas读取excel/"><span>pandas读取excel</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Rr-shan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="../../../../js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>