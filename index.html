<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Rr-shan,undefined"><meta name="copyright" content="Rr-shan"><title>【Sanzzi】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Rr-shan</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Rr-shan" target="_blank">GitHub<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="mailto:1224559633@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color10"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">20</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Sanzzi</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2020/03/29/srf之论文汇报流程/">srf之论文汇报流程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h2 id="论文将要讲述的方面"><a href="#论文将要讲述的方面" class="headerlink" title="论文将要讲述的方面"></a>论文将要讲述的方面</h2><ol>
<li>为什么要讲这个?（背景）</li>
<li>提出了什么 <strong>方法</strong> ?</li>
<li>传统方法有什么问题?（<strong>对比</strong>）</li>
<li><strong>原理</strong>简单讲一讲（数学方面要求不是很高，有代码实现更方便）?</li>
<li><strong>数据集</strong>是怎么<strong>划分</strong>的?</li>
<li><strong>交叉验证</strong>怎么做?</li>
</ol>
<h2 id="研究方法和主题"><a href="#研究方法和主题" class="headerlink" title="研究方法和主题"></a>研究方法和主题</h2><p>学长说在GCN方面不会有更深入的探寻了，会在以下几个方面找突破口</p>
<ul>
<li>==Attention机制==</li>
<li>==知识图谱==</li>
<li>==异构图网络的学习==</li>
<li>==嵌入式学习==</li>
</ul>
<h2 id="论文的选取"><a href="#论文的选取" class="headerlink" title="论文的选取"></a>论文的选取</h2><blockquote>
<p><strong>新</strong>（前沿），在期刊上发表的更好<br>有代码最好，有名字的模型在github上可以搜索的到</p>
</blockquote>
<h2 id="学长目前的想法"><a href="#学长目前的想法" class="headerlink" title="学长目前的想法"></a>学长目前的想法</h2><ul>
<li>SMILES收集之后：通过label encoding提取smiles的embedding<br><img src="srf%E4%B9%8B%E8%AE%BA%E6%96%87%E6%B1%87%E6%8A%A5%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></li>
</ul>
</div></div><a class="button-hover more" href="/2020/03/29/srf之论文汇报流程/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/03/29/VIM初级/"></a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"></div></div><a class="button-hover more" href="/2020/03/29/VIM初级/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/26/web小项目/">Web小项目(react调试和部署)</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h2 id="如何在本地调试react项目"><a href="#如何在本地调试react项目" class="headerlink" title="如何在本地调试react项目"></a>如何在本地调试react项目</h2><blockquote>
<p>在项目终端下(pycharm)运行 <figure class="highlight plain"><figcaption><span>install```**安装依赖**</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">项目会生成**node_modules**目录</span><br><span class="line">- 我们在在项目终端下(pycharm)运行</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>npm start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">浏览器会自动打开http://localhost:3000运行调试</span><br><span class="line"></span><br><span class="line">## 如何将本地的react项目部署到云服务器上</span><br><span class="line">- 我们在在项目终端下(pycharm)运行</span><br></pre></td></tr></table></figure>

<p>npm run build</p>
<pre><code>项目会生成了一个**build**目录

打开宝塔服务器页面，到相关网站下，将build页面下==static上传，以及和static平行的文件上传。==

至此，大功告成！
tips:感觉网上的教程大多数很复杂，暂时也不太明白他们做的原理(TODO)</code></pre></div></div><a class="button-hover more" href="/2020/02/26/web小项目/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/15/springcloud/">SpringCloud</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><p>纯洁的微笑关于springcloud的知识是2017年的</p>
<p>在使用了一段时间后发现Spring Cloud从技术架构上降低了对大型系统构建的要求，使我们以非常低的成本（技术或者硬件）搭建一套高效、分布式、容错的平台，但Spring Cloud也不是没有缺点，小型独立的项目不适合使用。</p>
<p>Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<ol>
<li>大话Spring Cloud 核心成员的介绍</li>
</ol>
<p>目前，国内使用 Spring Cloud 技术的公司并不多见，不是因为 Spring Cloud 不好，主要原因有以下几点：</p>
<ol>
<li>Spring Cloud 中文文档较少，出现问题网上没有太多的解决方案。</li>
<li>国内创业型公司技术老大大多是阿里系员工，而阿里系多采用 Dubbo 来构建微服务架构。（阿里已经采用了）</li>
<li>大型公司基本都有自己的分布式解决方案，而中小型公司的架构很多用不上微服务，所以没有采用 Spring Cloud 的必要性。</li>
</ol>
</div></div><a class="button-hover more" href="/2020/02/15/springcloud/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/13/Python词云/">Python词云</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-02-14</time></div><div class="post-content"><div class="main-content content"><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy matplotlib pillow wordcloud imageio jieba snownlp itchat -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>用清华的镜像速度好评</p>
<p>网上提供的图片素材太少了，只好用自己一般的画工作图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入imageio库中的imread函数，并用这个函数读取本地图片，作为词云形状图片</span></span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line">mk = imageio.imread(<span class="string">"xiaolan.png"</span>)</span><br><span class="line">w = wordcloud.WordCloud(mask=mk)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建并配置词云对象w，注意要加scale参数，提高清晰度</span></span><br><span class="line">w = wordcloud.WordCloud(width=<span class="number">1000</span>,</span><br><span class="line">                        height=<span class="number">700</span>,</span><br><span class="line">                        background_color=<span class="string">'white'</span>,</span><br><span class="line">                        font_path=<span class="string">'simkai.ttf'</span>,</span><br><span class="line">                        mask=mk,</span><br><span class="line">                        scale=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对来自外部文件的文本进行中文分词，得到string  ，有可能会遇到编码问题，这个可以根据报错来</span></span><br><span class="line">f = open(<span class="string">'知乎甜话.txt'</span>)</span><br><span class="line">txt = f.read()</span><br><span class="line">txtlist = jieba.lcut(txt)</span><br><span class="line">string = <span class="string">" "</span>.join(txtlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将string变量传入w的generate()方法，给词云输入文字</span></span><br><span class="line">w.generate(string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将词云图片导出到当前文件夹</span></span><br><span class="line">w.to_file(<span class="string">'chao1.png'</span>)</span><br></pre></td></tr></table></figure>

<p>上传不了图片！</p>
<p>TODO：颜色 &amp; 字体</p>
</div></div><a class="button-hover more" href="/2020/02/13/Python词云/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/10/惩罚线性回归模型/">惩罚线性回归模型</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-02-10</time></div><div class="post-content"><div class="main-content content"><h1 id="惩罚线性回归"><a href="#惩罚线性回归" class="headerlink" title="惩罚线性回归"></a>惩罚线性回归</h1><p>产生背景：<br>线性回归可以理解为“拟合”，一般采用普通最小二乘方法OLS（ordinary least square），但是对于拟合问题存在一个过拟合的问题，为了避免这种现象，提出了惩罚线性回归模型，要求模型对于训练数据具有较好的<strong>学习能力</strong>，同时也要<strong>平衡系数参数的惯性能量</strong></p>
<h2 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h2><p>通过设置不同大小的alpha，获得最终的预测结果以及ROC曲线，通过比较ROC曲线下的面积（AUC）获得optimal alpha。AUC越大越好。另外一般就取alpha=0.85吧。</p>
<h2 id="求解惩罚线性回归问题"><a href="#求解惩罚线性回归问题" class="headerlink" title="求解惩罚线性回归问题"></a>求解惩罚线性回归问题</h2><p>最小角度回归LARS算法<br>10折交叉验证就是将输入数据且分为10份几乎均等的数据（10折表示10%用于测试，5折表示20%用于测试）</p>
<p>我们采用自己实现的LARS算法，实现求解惩罚线性回归问题。而在python里面有直接的安装包实现lasso（套索）回归型函数。</p>
</div></div><a class="button-hover more" href="/2020/02/10/惩罚线性回归模型/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/07/R语言（DrImpute &amp; VIPER）/">R语言（DrImpute &amp; VIPER）</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-02-15</time></div><div class="post-content"><div class="main-content content"><h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><h3 id="技术型的"><a href="#技术型的" class="headerlink" title="技术型的"></a>技术型的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zero.rate &lt;- apply(xx, 1, function(x)&#123;length(x[x == 0])&#125;)/n</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zero.matrix &lt;- apply(zero.matrix, 2, as.numeric)</span><br></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply(,,)"></a>apply(,,)</h4><p>第一个参数是指要参与计算的<strong>矩阵</strong><br>第二个参数是指按行计算还是按列计算，1——表示按<strong>行</strong>计算，2——按<strong>列</strong>计算<br>第三个参数是指具体的运算参数。 (sum ,可以自定义，此处是自定义)</p>
<p>第三个参数为as.numeric不知道有什么用？<br>as.numeric 转化成整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag &lt;-  zero.rate &lt;= percentage.cutoff</span><br></pre></td></tr></table></figure>

<h4 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h4><p>&lt;=<br>检查第一向量的每个元素是否小于或等于第二向量的相应元素。</p>
<p>%%<br>两个向量求余<br>％/％<br>两个向量相除求商<br>^<br>将第二向量作为第一向量的指数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D &lt;- D + Y[i, ]%*%t(Y[i, ])</span><br></pre></td></tr></table></figure>

<p>%*%<br>表示通常意义下的两个矩阵的乘积</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(percentage.cutoff &gt;= 0.25)</span><br><span class="line">    warnings(&apos;The prediction model may not be accurate since there are not enough genes that have low zero rates.&apos;)</span><br></pre></td></tr></table></figure>

<h4 id="warnings-‘’"><a href="#warnings-‘’" class="headerlink" title="warnings(‘’)"></a>warnings(‘’)</h4><p>友好提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx &lt;- as.matrix(xx)</span><br></pre></td></tr></table></figure>

<h4 id="as-matrix"><a href="#as-matrix" class="headerlink" title="as.matrix()"></a>as.matrix()</h4><p>将其参数转换为矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- logxx[round(runif(num)*p), ]</span><br></pre></td></tr></table></figure>

<h4 id="runif"><a href="#runif" class="headerlink" title="runif()"></a>runif()</h4><p>runif()函数用于生成从0到1区间范围内的服从正态分布的随机数，每次生成的值都不一样；set.seed()用于生成随机数的种子元素，两个函数配合起来发挥作用。</p>
<h4 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h4><p>round函数用于舍入到最接近的整数。round(2.1) = 2;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selection &lt;- match.arg(selection)</span><br></pre></td></tr></table></figure>

<h4 id="match-arg"><a href="#match-arg" class="headerlink" title="match.arg()"></a>match.arg()</h4><p>match.arg可以用来做类型匹配</p>
<h4 id><a href="#" class="headerlink" title="$"></a>$</h4><p>当一个函数里需要返回多个值（比如有变量，有向量，有矩阵）时，我们要用list,而不是return，这时如果想提取某个变量的结果，就需要用到$，默认情况下，对于 ‘list’, ‘environment’这两种对象，$ 可以提取（extract）出里面的元素。<br>x$y  等价于 x[[“y”, exact = FALSE]]，用于获取dataframe或者list里面的某个变量，比如mtcars$cyl 和 diamonds$carat。不同之处在于 $ 可以部分匹配变量名，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- list(abc = 1)</span><br><span class="line">x$a</span><br><span class="line">#&gt; [1] 1</span><br><span class="line">x[[&quot;a&quot;]]</span><br><span class="line">#&gt; NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RcppExports.R</span><br></pre></td></tr></table></figure>

<h4 id="RcppExports-R"><a href="#RcppExports-R" class="headerlink" title="RcppExports.R"></a>RcppExports.R</h4><p>其不可删除，删除了也会自动再出现。其调用了.cpp的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">suppressMessages(require(quadprog))</span><br></pre></td></tr></table></figure>

<h4 id="suppressMessages"><a href="#suppressMessages" class="headerlink" title="suppressMessages()"></a>suppressMessages()</h4><p>使用suppressMessages运行的时候不显示提示信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d &lt;- rep(0, k)</span><br></pre></td></tr></table></figure>

<h4 id="rep-x-time-length-each"><a href="#rep-x-time-length-each" class="headerlink" title="rep(x, time = , length = , each = ,)"></a>rep(x, time = , length = , each = ,)</h4><p>x：代表的是你要进行复制的对象，可以是一个向量或者是一个因子。<br>times：代表的是复制的次数，只能为正数。负数以及NA值都会为错误值。复制是指的是对整个向量进行复制。<br>each：代表的是对向量中的每个元素进行复制的次数。<br>length.out：代表的是最终输出向量的长度。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line">rep(1:4, 2)  #对向量（1,2,3,4）复制两次</span><br><span class="line">[1] 1 2 3 4 1 2 3 4</span><br><span class="line">rep(1:4, each = 2)   #对向量（1,2,3,4）中的每个元素复制两次</span><br><span class="line">[1] 1 1 2 2 3 3 4 4</span><br><span class="line">rep(1:4, each = 2, length.out = 4)  #最后输出向量的长度为4</span><br><span class="line">[1] 1 1 2 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A &lt;- rbind(diag(k), - diag(k))</span><br></pre></td></tr></table></figure>

<h4 id="rbind-a-b"><a href="#rbind-a-b" class="headerlink" title="rbind(a,b)"></a>rbind(a,b)</h4><p>cbind： 根据列进行合并，即叠加所有列，m列的矩阵与n列的矩阵cbind()最后变成m+n列，合并前提：cbind(a, c)中矩阵a、c的行数必需相符</p>
<p>rbind： 根据行进行合并，就是行的叠加，m行的矩阵与n行的矩阵rbind()最后变成m+n行，合并前提：rbind(a, c)中矩阵a、c的列数必需相符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line">&gt; a &lt;- matrix(1:12, 3, 4)</span><br><span class="line">&gt; print(a)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    4    7   10</span><br><span class="line">[2,]    2    5    8   11</span><br><span class="line">[3,]    3    6    9   12</span><br><span class="line">&gt; </span><br><span class="line">&gt; b &lt;- matrix(-1:-12, 3, 4)</span><br><span class="line">&gt; print(b)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]   -1   -4   -7  -10</span><br><span class="line">[2,]   -2   -5   -8  -11</span><br><span class="line">[3,]   -3   -6   -9  -12</span><br><span class="line">&gt; </span><br><span class="line">&gt; x=cbind(a,b)</span><br><span class="line">&gt; print(x)</span><br><span class="line">     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]</span><br><span class="line">[1,]    1    4    7   10   -1   -4   -7  -10</span><br><span class="line">[2,]    2    5    8   11   -2   -5   -8  -11</span><br><span class="line">[3,]    3    6    9   12   -3   -6   -9  -12</span><br><span class="line">&gt; </span><br><span class="line">&gt; y=rbind(a,b)</span><br><span class="line">&gt; print(y)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    4    7   10</span><br><span class="line">[2,]    2    5    8   11</span><br><span class="line">[3,]    3    6    9   12</span><br><span class="line">[4,]   -1   -4   -7  -10</span><br><span class="line">[5,]   -2   -5   -8  -11</span><br><span class="line">[6,]   -3   -6   -9  -12</span><br></pre></td></tr></table></figure>

<h4 id="diag"><a href="#diag" class="headerlink" title="diag()"></a>diag()</h4><p>diag()提取或替换一个矩阵的对角线,或构造一个对角矩阵。<br>语法：<br>diag(x = 1, nrow, ncol)<br>diag(x) &lt;- value<br>解析：<br>x：一个矩阵,向量或一维数组,或不填写。<br>nrow, ncol：可选 行列。<br>value ：对角线的值，可以是一个值或一个向量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line">&gt; x &lt;- matrix(1:16,nrow=4,ncol=4)</span><br><span class="line">&gt; x</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    5    9   13</span><br><span class="line">[2,]    2    6   10   14</span><br><span class="line">[3,]    3    7   11   15</span><br><span class="line">[4,]    4    8   12   16</span><br><span class="line">&gt; diag(x)</span><br><span class="line">[1]  1  6 11 16</span><br><span class="line">#展示x的对角线数据</span><br><span class="line"></span><br><span class="line">&gt; diag(diag(x))</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    0    0    0</span><br><span class="line">[2,]    0    6    0    0</span><br><span class="line">[3,]    0    0   11    0</span><br><span class="line">[4,]    0    0    0   16</span><br><span class="line">#由x的对角线数据生成对角矩阵</span><br><span class="line"></span><br><span class="line">&gt; diag(4)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    0    0    0</span><br><span class="line">[2,]    0    1    0    0</span><br><span class="line">[3,]    0    0    1    0</span><br><span class="line">[4,]    0    0    0    1</span><br><span class="line">#对角线为4个元素每个元素默认为1的对角矩阵</span><br><span class="line"></span><br><span class="line">&gt; diag(10,3,4)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]   10    0    0    0</span><br><span class="line">[2,]    0   10    0    0</span><br><span class="line">[3,]    0    0   10    0</span><br><span class="line">#对角线数据位10,三行四列的矩阵</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; a&lt;-diag(4)+1</span><br><span class="line">&gt; a</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    2    1    1    1</span><br><span class="line">[2,]    1    2    1    1</span><br><span class="line">[3,]    1    1    2    1</span><br><span class="line">[4,]    1    1    1    2</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Visualiztion</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">palette.gr.marray &lt;- colorRampPalette(c(&quot;white&quot;, &quot;red&quot;))(4)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="colorRampPalette-c-“white”-“red”-4"><a href="#colorRampPalette-c-“white”-“red”-4" class="headerlink" title="colorRampPalette(c(“white”, “red”))(4)"></a>colorRampPalette(c(“white”, “red”))(4)</h4><p>函数的参数c(“white”, “red”) 指的是颜色从红色渐变到红色，4 代表创建长度为4的颜色梯度<br>有了颜色梯度之后，我们就可以方便的把数值映射到颜色梯度上<br>基本的思想是，将数值排序，然后得到每个数值在排序好的序列中的顺序，其实就是rank 函数的返回值，然后利用该顺序去获取颜色</p>
<p>##　DrImpute</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cor()</span><br></pre></td></tr></table></figure>

<p>R内置函数cor()可以用来计算相关系数：cor(x, method = c(“pearson”, “kendall”, “spearman”))，如果数据有缺失值，用cor(x, method = “pearson”, use = “complete.obs”)。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expand.grid()</span><br></pre></td></tr></table></figure>

<p>构造一个数据框，将各参数的各水平完全搭配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ikwak2/DrImpute</span><br></pre></td></tr></table></figure>

<p>这个好像是经过改进的</p>
<p>主成分分析 (PCA, principal component analysis)是一种数学降维方法, 利用正交变换 (orthogonal transformation)把一系列可能线性相关的变量转换为一组线性不相关的新变量，也称为主成分，从而利用新变量在更小的维度下展示数据的特征。</p>
<p>主成分是原有变量的线性组合，其数目不多于原始变量。组合之后，相当于我们获得了一批新的观测数据，这些数据的含义不同于原有数据，但包含了之前数据的大部分特征，并且有着较低的维度，便于进一步的分析。</p>
<p>在空间上，PCA可以理解为把原始数据投射到一个新的坐标系统，第一主成分为第一坐标轴，它的含义代表了原始数据中多个变量经过某种变换得到的新变量的变化区间；第二成分为第二坐标轴，代表了原始数据中多个变量经过某种变换得到的第二个新变量的变化区间。这样我们把利用原始数据解释样品的差异转变为利用新变量解释样品的差异。</p>
</div></div><a class="button-hover more" href="/2020/02/07/R语言（DrImpute &amp; VIPER）/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/06/账号中心/">账号中心</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-02-14</time></div><div class="post-content"><div class="main-content content"><ul>
<li>DAO层：<blockquote>
<p>DAO层叫<strong>数据访问层</strong>，全称为<strong>data access object</strong>，属于一种比较底层，比较基础的操作，具体到对于某个<em>表的增删改查</em>，建议DAO只做原子操作，增删改查。<br>通常我们在DAO层里面写<strong>接口</strong>，里面有与数据打交道的方法。SQL语句通常写在mapper文件里面的。</p>
</blockquote>
</li>
</ul>
<ul>
<li>Controler层：<blockquote>
<p>Controler负责请求转发，接收页面过来的参数，传给<strong>Service</strong>处理，接到返回值，再传给页面。</p>
</blockquote>
</li>
</ul>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法。通俗来说，被Controller标记的类就是一个控制器，这个类中的方法，就是相应的动作。</p>
<p>Alt+Insert键可以加入get和set方法</p>
</div></div><a class="button-hover more" href="/2020/02/06/账号中心/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/05/yc的聊天器（Ubuntu）/">yc的聊天器（NIO）</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 本机client编号</span><br><span class="line"> */</span><br><span class="line">private int thisClientNumber = -1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 客户端多路选择器</span><br><span class="line"> */</span><br><span class="line">private Selector selector;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 客户端和服务端连接channel</span><br><span class="line"> */</span><br><span class="line">private SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 聊天工具类</span><br><span class="line"> */</span><br><span class="line">private ChartUtil chartUtil;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Client client = new Client();</span><br><span class="line">    client.initial();</span><br><span class="line">    client.inputThread();</span><br><span class="line">    client.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br></pre></td></tr></table></figure>

<p>从通道读取：创建一个缓冲区，然后请求通道读取数据。<br>通道写入：创建一个缓冲区，填充数据，并要求通道写入数据。</p>
<p><strong>核心部件</strong></p>
<ul>
<li>Channel</li>
<li>Buffer</li>
<li><em>Selector</em></li>
</ul>
<p><strong>通道列表</strong></p>
<ul>
<li>DatagramChannel</li>
<li><em>SocketChannel</em></li>
<li>FileChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p><strong>缓冲列表</strong></p>
<ul>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li><em>ByteBuffer</em></li>
<li>ShortBuffer</li>
<li>FloatBuffer</li>
</ul>
<p><strong>选择器</strong><br>Java NIO提供了“选择器”的概念。这是一个可以用于监视多个通道的对象，如数据到达，连接打开等。因此，单线程可以监视多个通道中的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SneakyThrows</span><br><span class="line">private void initial() &#123;</span><br><span class="line">    selector = Selector.open();</span><br><span class="line">    socketChannel = SocketChannel.open();</span><br><span class="line">    socketChannel.configureBlocking(false);</span><br><span class="line">    chartUtil = new ChartUtil();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span>接着看完</span></span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2020/02/05/yc的聊天器（Ubuntu）/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/03/人脸识别的项目/">人脸识别的项目</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><p>安装包的过程异常艰难<br><strong>缺失文件haarcascades—各种分类器xml文件下载地址</strong><br>在github上面下载的速度实在是太慢了</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1UECA2mPDwqMrhLfWaRTi8g" target="_blank" rel="noopener">https://pan.baidu.com/s/1UECA2mPDwqMrhLfWaRTi8g</a><br>提取码：gqvl </p>
</blockquote>
<p><strong>安装dlib模块踩坑</strong><br>网上各种各样的方法，boost,cmake,还需要VS，非常十分复杂，我怀着想要简约一些的方式开始bing。</p>
<p>避开最复杂的做法</p>
<p>找相对简单的做法：<br><em>conda安装最新的dlib</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c menpo dlib=19.9</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge dlib</span><br><span class="line">conda install -c conda-forge/label/cf201901 dlib</span><br></pre></td></tr></table></figure>

<h4 id="报错1："><a href="#报错1：" class="headerlink" title="报错1："></a>报错1：</h4><p>网络连接不上</p>
<p><em>windows 通过whl文件安装dlib</em></p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_39954229/article/details/81878864" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39954229/article/details/81878864</a><br>可以下载这个dlib-19.7.0-cp36-cp36m-win_amd64.whl</p>
</blockquote>
<blockquote>
<p><a href="https://www.jianshu.com/p/8296f2aac1aa" target="_blank" rel="noopener">https://www.jianshu.com/p/8296f2aac1aa</a><br>中可以下载dlib-19.8.1-cp36-cp36m-win_amd64.whl</p>
</blockquote>
<blockquote>
<p><a href="https://pypi.org/simple/dlib/" target="_blank" rel="noopener">https://pypi.org/simple/dlib/</a> 这链接几乎啥版本都有</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install D:\Downloads\dlib-19.7.0-cp36-cp36m-win_amd64.whl</span><br><span class="line">一定要注意文件的路径</span><br></pre></td></tr></table></figure>

<h4 id="报错2："><a href="#报错2：" class="headerlink" title="报错2："></a>报错2：</h4><p>ERROR: dlib-19.7.0-cp36-cp36m-win_amd64.whl is not a supported wheel on this platform.</p>
<p>原因1：版本不匹配（Python和包（库）不兼容）<br>如何查看<br>参照博客<a href="https://blog.csdn.net/xiuxiuen_michelle/article/details/81080694" target="_blank" rel="noopener">https://blog.csdn.net/xiuxiuen_michelle/article/details/81080694</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">import pip._internal</span><br><span class="line">print(pip._internal.pep425tags.get_supported())</span><br></pre></td></tr></table></figure>

<p>发现了问题，cp37才可以，之前是cp36的，以上提供的版本对Python来说无用。</p>
<p>感人的是，知乎上Python回答者居然提供了cp37的</p>
<blockquote>
<p><a href="https://pan.baidu.com/s/1MKqW7WH2XP-J8MOLeq3cDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1MKqW7WH2XP-J8MOLeq3cDA</a><br>提取码：rfh8</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install D:\Downloads\dlib-19.17.99-cp37-cp37m-win_amd64.whl</span><br></pre></td></tr></table></figure>

<p><strong>安装face_recognition人脸识别库</strong><br>安装了dlib后还是安装不成功</p>
<p>方法一：先安装cmake再安装face_recognition<br>但是cmake也不能直接pip,cmake的安装非常复杂（stop）<br>方法二：用whl文件<br>官网<a href="https://pypi.org/project/pip/20.0.2/#files下载" target="_blank" rel="noopener">https://pypi.org/project/pip/20.0.2/#files下载</a><br>pip-20.0.2-py2.py3-none-any.whl<br>好蠢啊，看错了，下错了，又因为网速实在不给力</p>
<p>直接在官网内搜，什么都可以<br>官网<a href="https://pypi.org/project/face_recognition/#files" target="_blank" rel="noopener">https://pypi.org/project/face_recognition/#files</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install D:\Downloads\face_recognition-1.2.3-py2.py3-none-any.whl</span><br></pre></td></tr></table></figure>

<h4 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h4><p>Script file ‘D:\Anaconda\Scripts\pip-script.py’ is not present.<br>原因是我下载错了包，安装的时候把原有的pip给卸载了<br>方法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install pip</span><br></pre></td></tr></table></figure>

<p>安装成功</p>
<h4 id="报错：-1"><a href="#报错：-1" class="headerlink" title="报错："></a>报错：</h4><p>UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x81 in position 4: illegal multibyte sequence</p>
<p>都是编码的问题<br>stackoverflow</p>
<blockquote>
<p>if you will open file with utf-8,then you need write: open(file_name, ‘r’, encoding=’UTF-8’) if you will open file with GBK,then you need do: open(file_name, ‘rb’) hope to solve your problem!</p>
</blockquote>
<blockquote>
<ul>
<li>encoding=’UTF-8’出现了utf-8的报错，加入’rb’无效</li>
<li>没看清楚CSDN博主的错误地方，安装了pip download pyleus<br>pip install pyleus-0.3.0.tar.gz</li>
<li>修改编码错误的地方，改成gbk，或者神奇的gbk10……</li>
</ul>
</blockquote>
<p> 我好傻，一大早将笔记中的D:\Anaconda\Lib\site-packages\dlib-data\shape_predictor_68_face_landmarks.dat当成要下载的下载了，以至于编码一直出现错误</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install D:\Downloads\face_recognition-1.2.3-py2.py3-none-any.whl</span><br></pre></td></tr></table></figure>

<p> 下载速度好慢呐<br>翻墙后就安装上了</p>
<p><strong>缺失文件shape_predictor_68_face_landmarks.dat</strong></p>
<blockquote>
<p><a href="https://pan.baidu.com/s/1Z1a_ud__BWXgCWZeSdpL2g" target="_blank" rel="noopener">https://pan.baidu.com/s/1Z1a_ud__BWXgCWZeSdpL2g</a><br>提取码：lzjy</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\\Anaconda\\Lib\\site-packages\\dlib-data\\shape_predictor_68_face_landmarks.dat</span><br></pre></td></tr></table></figure>

<p><a href="https://www.osgeo.cn/pygis/basemap-eqexam.html" target="_blank" rel="noopener">https://www.osgeo.cn/pygis/basemap-eqexam.html</a><br>地图绘制</p>
<p>需要Python的配置文件，这里都有<br>python!<br><a href="https://my.oschina.net/chenmoxuan/blog/1827753" target="_blank" rel="noopener">https://my.oschina.net/chenmoxuan/blog/1827753</a><br><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>
</div></div><a class="button-hover more" href="/2020/02/03/人脸识别的项目/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Rr-shan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>