<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Rr-shan,undefined"><meta name="copyright" content="Rr-shan"><title>【Sanzzi】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Rr-shan</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Rr-shan" target="_blank">GitHub<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="mailto:1224559633@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="archives"><span class="pull-top">日志</span><span class="pull-bottom">29</span></a><a class="author-info-articles-tags article-meta" href="tags"><span class="pull-top">标签</span><span class="pull-bottom">2</span></a></div><div class="friend-link"><a class="friend-link-text" href="https://chao-yin-github.github.io/" target="_blank">yccccc~~~~~~~~</a><a class="friend-link-text" href="https://sanzzi.cn" target="_blank">Mywebsite</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Sanzzi</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="2020/04/01/srf之论文阅读Dr.VAE/">srf之论文阅读Dr.VAE</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-01</time></div><div class="post-content"><div class="main-content content"><h1 id="Dr-VAE-improving-drug-response-prediction-via-modeling-of-drug-perturbation-effects"><a href="#Dr-VAE-improving-drug-response-prediction-via-modeling-of-drug-perturbation-effects" class="headerlink" title="Dr.VAE: improving drug response prediction via modeling of drug perturbation effects"></a>Dr.VAE: improving drug response prediction via modeling of drug perturbation effects</h1><h2 id="1-为什么要讲这个"><a href="#1-为什么要讲这个" class="headerlink" title="1. 为什么要讲这个?"></a>1. 为什么要讲这个?</h2><p><strong>Motivation:</strong><br>将<strong>生物逻辑系统的先验知识</strong>融入到这些方法中是<strong>提高预测性能</strong>的一个很有前途的途径。<br><strong>药物诱导转录组微扰效应的高通量细胞系分析</strong>(High-throughput cell line assays of drug-induced transcriptomic perturbation effects)是一项尚未完全纳入药物反应预测模型的先验知识。</p>
<h2 id="2-提出了什么方法"><a href="#2-提出了什么方法" class="headerlink" title="2. 提出了什么方法 ?"></a>2. 提出了什么方法 ?</h2><p>引入了一个统一的<strong>概率方法</strong>，<strong>Dr.VAE</strong>(Drug Response Variational Autoencoder、药物反应变分自动编码器），它同时根据<strong>活性</strong>和<strong>转录组的扰动</strong>来模拟药物反应。<del>翻译怪怪的??</del> </p>
<p>已知：</p>
<ol>
<li>VAE可以提取出具有生物学意义的癌症经切切片特征</li>
<li>在一种名为DeepProfile的药物反应预测方法中，将预先训练的VAE和单独训练的线性模型相结合。<br>我们旨在共同学习一种潜在的嵌入方法，以提高我们预测药物反应（表型结果）的能力，同时利用最初不受监督的（未知表型结果）药物每次扰动实验来帮助学习这种嵌入方法。</li>
</ol>
<p>放模型图！</p>
<h2 id="3-传统方法有什么问题-（对比）"><a href="#3-传统方法有什么问题-（对比）" class="headerlink" title="3. 传统方法有什么问题?（对比）"></a>3. 传统方法有什么问题?（对比）</h2><p>现有的机器学习算法：<br>深度学习的方法：典型的判别前馈神经网络在药物反应预测中效果不佳，很可能是由于数据限制（特征数量与样本数量）所致。</p>
<p>Result部分<br><em>代码体现</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classif_baseline_perf</span><span class="params">(xtrain, ytrain, xtest, ytest, svmkernel=<span class="string">'rbf'</span>, rseed=None)</span>:</span></span><br><span class="line">    <span class="string">'''这个包括了和 Random Forest、LogisticRegression、SVM、SVM w/ linear kernel的对比'''</span></span><br><span class="line">    data = [xtrain, ytrain, xtest, ytest]</span><br><span class="line">    perf = OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## Random Forest</span></span><br><span class="line">    cl = sklearn.ensemble.RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=rseed)</span><br><span class="line">    rf_perf = measure_cl_perf(cl, <span class="string">'RF100'</span>, *data)</span><br><span class="line">    perf = concat_dicts(perf, rf_perf)</span><br><span class="line"></span><br><span class="line">	<span class="comment">## LogisticRegression</span></span><br><span class="line">    cl = sklearn.linear_model.LogisticRegressionCV(penalty=<span class="string">'l2'</span>, random_state=rseed)</span><br><span class="line">    lr_perf = measure_cl_perf(cl, <span class="string">'Ridge'</span>, *data)</span><br><span class="line">    perf = concat_dicts(perf, lr_perf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## SVM </span></span><br><span class="line">    cl = sklearn.svm.SVC(kernel=svmkernel, probability=<span class="literal">True</span>, random_state=rseed)</span><br><span class="line">    svm_perf = measure_cl_perf(cl, <span class="string">'SVM'</span> + svmkernel[:<span class="number">3</span>], *data)</span><br><span class="line">    perf = concat_dicts(perf, svm_perf)</span><br><span class="line">    <span class="comment"># SVM w/ linear kernel</span></span><br><span class="line">    cl = sklearn.svm.SVC(kernel=<span class="string">'linear'</span>, probability=<span class="literal">True</span>, random_state=rseed)</span><br><span class="line">    svm_perf = measure_cl_perf(cl, <span class="string">'SVMlin'</span>, *data)</span><br><span class="line">    perf = concat_dicts(perf, svm_perf)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> perf</span><br></pre></td></tr></table></figure>

<p>measure_cl_perf()函数作用是评估，计算出的是Acc、AUROC、AUPR<br>concat_dicts()转化为字典</p>
<h2 id="4-原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）"><a href="#4-原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）" class="headerlink" title="4. 原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）?"></a>4. 原理简单讲一讲（数学方面要求不是很高，有代码实现更方便）?</h2><h2 id="5-数据集是怎么划分的"><a href="#5-数据集是怎么划分的" class="headerlink" title="5. 数据集是怎么划分的?"></a>5. 数据集是怎么划分的?</h2><blockquote>
<p><strong>Training data sets</strong>：<strong>CTRPv2</strong>( Cancer Therapeutic Response Portal)  &amp;  <strong>CMap</strong> (CMap-L1000v1)<br><strong>Input data types</strong>：<strong>mRNA</strong> EXP (before &amp; after treatment)</p>
</blockquote>
<h3 id="两个数据集的基本介绍："><a href="#两个数据集的基本介绍：" class="headerlink" title="两个数据集的基本介绍："></a>两个数据集的基本介绍：</h3><p><strong>CTRPv2</strong>：为860个细胞系和481个药物化合物的组合<strong>提供了不同药物浓度下细胞系的相对生存能力</strong>。细胞系对<strong>药物治疗的敏感性</strong>通过<strong>剂量-反应曲线AAC</strong>上方的面积来量化，我们进一步采用瀑布法对连续的AAC进行二值化（Barretina等人，2012；Haibe-Kains等人，2013），<strong>将灵敏度预测任务转化为离散的分类任务。</strong>  <del>体现在哪里？</del><br><strong>CMap</strong>：筛选了19 811种药物化合物对多达77个细胞系中L1000个标志性基因表达的干扰效应。<br>在CMap中的实验并<strong>不能测量药物治疗的敏感性</strong>，但是一些细胞系也在CTRPv2中进行了独立的测试。我们<strong>交叉</strong>引用这些细胞系(取交集)，并将相应的标签分配给它们的扰动测量。</p>
<h3 id="实验数据选择标准："><a href="#实验数据选择标准：" class="headerlink" title="实验数据选择标准："></a>实验数据选择标准：</h3><ol>
<li>从CMap数据集，选择了在<strong>最常见浓度水平下对每种药物进行6小时的微扰实验</strong>。如果细胞系没有在选定的浓度下进行检测，我们使用最接近的检测浓度。接下来，我们将对照组（DMSO载体）实验与药物扰动实验通过批次ID和微珠ID进行匹配，以最小化病例和对照组之间的批次效应。<del>？？</del> 此外，我们通过相关性（&gt;0.75 Pearson q）过滤所选的病例对照对，以过滤出可能标记错误的实验或异常值。</li>
<li>CTRPv2和CMap-L1000v1数据集共有<strong>973</strong>个共同基因。将<strong>每个基因的表达值标准化为零均值和单位方差</strong>。为了进一步的均匀化，包括去除批效应和两个合并数据之间的差异，我们还从集合数据集中去除了第一个主成分（解释了12.8%的变化）。<br>叨叨：数据的筛选真的太讲究了<br>基于以上两个标准，我们选择了<strong>26</strong>种在CTRPv2和CMap-L1000v1数据集中测试的<strong>药物</strong>：</li>
</ol>
<ul>
<li>对于每种选择的药物，至少有<strong>8个不同的细胞系在CMap干扰实验中测试。</strong></li>
<li>CTRPv2中至少有20%的筛选细胞系在剂量-反应AAC二值化后<strong>对药物敏感</strong>。</li>
</ul>
<p><del>插图</del> </p>
<h2 id="7-交叉验证怎么做"><a href="#7-交叉验证怎么做" class="headerlink" title="7. 交叉验证怎么做?"></a>7. 交叉验证怎么做?</h2><p>通过执行20次重复的<strong>5倍交叉验证</strong>，我们生成了100个训练验证测试数据拆分。<br><em>代码体现</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSplitsByGroupKFold</span><span class="params">(groups, fold, n_splits, shuffle, random_state)</span>:</span></span><br><span class="line">    <span class="string">'''the same group will not appear in two different folds'''</span></span><br><span class="line">    <span class="keyword">assert</span> (n_splits &gt;= <span class="number">3</span>)</span><br><span class="line">    kf = GroupKFold(n_splits=n_splits)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> shuffle:</span><br><span class="line">        <span class="comment"># randomly rename groups so that the GroupKFold (which sorts by group ids first) splits can be randomized</span></span><br><span class="line">        unique_groups = np.unique(groups)</span><br><span class="line">        rnd_renames = sklearn.utils.shuffle(np.arange(len(unique_groups)), random_state=random_state)</span><br><span class="line">        groups_renamed = np.array([rnd_renames[np.argwhere(unique_groups == g)[<span class="number">0</span>]] <span class="keyword">for</span> g <span class="keyword">in</span> groups])</span><br><span class="line">        kfsplit = kf.split(X=np.zeros(groups.shape[<span class="number">0</span>]), groups=groups_renamed)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        kfsplit = kf.split(X=np.zeros(groups.shape[<span class="number">0</span>]), groups=groups)</span><br><span class="line">    allsplits = np.array([x <span class="keyword">for</span> x <span class="keyword">in</span> kfsplit])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(fold, list) <span class="keyword">or</span> isinstance(fold, tuple):</span><br><span class="line">        <span class="keyword">assert</span> (len(fold) == <span class="number">2</span>)</span><br><span class="line">        te_fold = fold[<span class="number">0</span>]</span><br><span class="line">        va_fold = fold[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        te_fold = fold</span><br><span class="line">        va_fold = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> (te_fold &gt;= <span class="number">1</span> <span class="keyword">and</span> te_fold &lt;= n_splits)      <span class="comment">## the test fold is between 1..n_splits</span></span><br><span class="line">    <span class="keyword">assert</span> (va_fold &gt;= <span class="number">1</span> <span class="keyword">and</span> va_fold &lt;= n_splits - <span class="number">1</span>)  <span class="comment">## the validation fold is between 1..(n_splits-1)</span></span><br><span class="line">    <span class="comment"># the te_fold is indexed from 1 so we need to subtract 1</span></span><br><span class="line">    te_fold_id = te_fold - <span class="number">1</span></span><br><span class="line">    va_fold_id = (te_fold_id + va_fold) % n_splits</span><br><span class="line">    ind_te = allsplits[te_fold_id][<span class="number">1</span>]</span><br><span class="line">    ind_va = allsplits[va_fold_id][<span class="number">1</span>]</span><br><span class="line">    ind_tr = np.concatenate(allsplits[np.setdiff1d(np.arange(n_splits), np.asarray([te_fold_id, va_fold_id]))][:, <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">assert</span> (checkSplit(ind_tr, ind_va, ind_te))</span><br><span class="line">    <span class="keyword">return</span> ind_tr, ind_va, ind_te</span><br></pre></td></tr></table></figure>

<h2 id="8-Discussion："><a href="#8-Discussion：" class="headerlink" title="8. Discussion："></a>8. Discussion：</h2><p>典型的判别前馈神经网络在药物反应预测中效果不佳，很可能是由于数据限制（特征数量与样本数量）所致。 我们表明，<strong>药物反应和扰动效应的联合生成模型</strong>在很大程度上缓解了这种情况，<strong>可能起到了有效的正则化和鲁棒的特征提取的作用</strong>，而不会产生过拟合的情况。</p>
<h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h3><ol>
<li>只考虑基因表达方式，<strong>没有额外整合</strong>甲基化、拷贝数变化、相互作用状态的<strong>多组预测因子。</strong></li>
<li>我们在每种药物最常见的浓度水平下，对治疗6小时后的CMap-L1000v1扰动进行建模。有人认为，<strong>6小时太短，许多反馈调节机制无法体现自己，因此这些实验本身并不能提供完整的转录反应图片</strong>。值得注意的是，药物细胞系活力测定通常在较长的治疗时间（如72小时）内完成。因此，我们也用24小时的微扰实验来训练我们的VAE博士，然而，<strong>由于这样的实验数量有限</strong>，这并没有提高我们的预测性能。</li>
<li>Dr.VAE所组成的每一个条件分布都是由一个神经网络参数化的。调整超参数以匹配数据复杂性的能力使Dr.VAE成为一个非常灵活的模型。<strong>由于我们选择了简单性，我们的神经网络大多有一个隐藏层，而分类后验函数和扰动函数是线性的。</strong> 然而，到目前为止，我们试图通过更复杂的分布使用更深的网络或使用规范化流来近似后验的尝试，<strong>并没有显著地提高性能来证明增加的复杂性。</strong></li>
</ol>
<hr>
<h2 id="预备-amp-补充知识："><a href="#预备-amp-补充知识：" class="headerlink" title="预备&amp;补充知识："></a>预备&amp;补充知识：</h2><h3 id="什么是VAE-Variational-auto-encoder、变分自编码器-？"><a href="#什么是VAE-Variational-auto-encoder、变分自编码器-？" class="headerlink" title="什么是VAE(Variational auto-encoder、变分自编码器)？"></a>什么是VAE(Variational auto-encoder、变分自编码器)？</h3><p>一个可以和GAN相媲美的生成网络。<br>VAE通过说我希望生成一张新的猫脸，那么这个n维向量代表的就是n个决定最终猫脸模样的隐形因素。对于每个因素，都对应产生一种分布，从这些分布关系中进行采样，那么我就可以通过一个深度网络恢复出最终的猫脸。<br>通过一个网络，将一个高维空间的人脸映射为低维空间的一个向量。那么如果我将这个向量定义为四维，采用one-hot的表达方式表达四张不同的脸，那么这个网络就可以表达四个脸，你输入不同的数据，他就会输出不同的脸来。</p>
<h4 id="VAE有什么用？"><a href="#VAE有什么用？" class="headerlink" title="VAE有什么用？"></a>VAE有什么用？</h4><p>VAE到底有什么用呢，就为了把大量的数据存储到网络结构中去呀，当然不能是这么简单的一个事。想象一下，在一个末日大片中，我们需要去搞出一个许多机器人占领世界的场面，但是我们的特效师一张张去画，这无疑会是一个令人头疼的工作，利用VAE，只需要使用有限的数据输入，我们就可以通过隐形参数的调节，获得几乎无限的数量。</p>
<h4 id="VAE网络结构组成："><a href="#VAE网络结构组成：" class="headerlink" title="VAE网络结构组成："></a>VAE网络结构组成：</h4><p>可以大致分成<strong>Encoder</strong>和<strong>Decoder</strong>两部分。对于输入图片，Encoder将提取得到编码：一个<strong>mean vector</strong>（均值）和一个<strong>deviation vector</strong>（方差），然后将这个编码（两个vector）作为Decoder的输入，最终输出一张和原图相近的图片。</p>
<p>它本质上就是在我们常规的自编码器的基础上，对 encoder 的结果（在VAE中对应着计算均值的网络）加上了<strong>“高斯噪声”</strong>，使得结果 decoder 能够对噪声有鲁棒性；而那个额外的 KL loss（目的是让均值为 0，方差为 1），事实上就是相当于对 encoder 的一个正则项，希望 encoder 出来的东西均有零均值。</p>
<p>drug perturbation effects是什么?</p>
<h3 id="ablation-study消融实验"><a href="#ablation-study消融实验" class="headerlink" title="ablation study消融实验:"></a>ablation study消融实验:</h3><p>论证是什么起了作用，类似于中学学的控制变量<br>模型简化测试。<br>看看取消掉一些模块后性能有没有影响。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><h4 id="文章："><a href="#文章：" class="headerlink" title="文章："></a>文章：</h4><p><a href="https://blog.csdn.net/weixin_40955254/article/details/82315224" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40955254/article/details/82315224</a><br><a href="https://blog.csdn.net/cjh_jinduoxia/article/details/84995156" target="_blank" rel="noopener">https://blog.csdn.net/cjh_jinduoxia/article/details/84995156</a></p>
<h4 id="视频："><a href="#视频：" class="headerlink" title="视频："></a>视频：</h4><p>（白板推导）<a href="https://www.bilibili.com/video/BV15E411w7Pz" target="_blank" rel="noopener">https://www.bilibili.com/video/BV15E411w7Pz</a></p>
</div></div><a class="button-hover more" href="2020/04/01/srf之论文阅读Dr.VAE/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/03/29/srf之论文汇报流程/">srf之论文汇报流程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h2 id="论文将要讲述的方面"><a href="#论文将要讲述的方面" class="headerlink" title="论文将要讲述的方面"></a>论文将要讲述的方面</h2><ol>
<li>为什么要讲这个?（背景）</li>
<li>提出了什么 <strong>方法</strong> ?</li>
<li>传统方法有什么问题?（<strong>对比</strong>）</li>
<li><strong>原理</strong>简单讲一讲（数学方面要求不是很高，有代码实现更方便）?</li>
<li><strong>数据集</strong>是怎么<strong>划分</strong>的?</li>
<li><strong>交叉验证</strong>怎么做?</li>
</ol>
<h2 id="研究方法和主题"><a href="#研究方法和主题" class="headerlink" title="研究方法和主题"></a>研究方法和主题</h2><p>学长说在GCN方面不会有更深入的探寻了，会在以下几个方面找突破口</p>
<ul>
<li>Attention机制</li>
<li>知识图谱</li>
<li>异构图网络的学习</li>
<li>嵌入式学习</li>
</ul>
<h2 id="论文的选取"><a href="#论文的选取" class="headerlink" title="论文的选取"></a>论文的选取</h2><blockquote>
<p><strong>新</strong>（前沿），在期刊上发表的更好<br>有代码最好，有名字的模型在github上可以搜索的到</p>
</blockquote>
<h2 id="学长目前的想法"><a href="#学长目前的想法" class="headerlink" title="学长目前的想法"></a>学长目前的想法</h2><ul>
<li>SMILES收集之后：通过label encoding提取smiles的embedding<br><img src="srf%E4%B9%8B%E8%AE%BA%E6%96%87%E6%B1%87%E6%8A%A5%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></li>
</ul>
</div></div><a class="button-hover more" href="2020/03/29/srf之论文汇报流程/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/26/web小项目/">Web小项目(react调试和部署)</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h2 id="如何在本地调试react项目"><a href="#如何在本地调试react项目" class="headerlink" title="如何在本地调试react项目"></a>如何在本地调试react项目</h2><blockquote>
<p>在项目终端下(pycharm)运行 <figure class="highlight plain"><figcaption><span>install```**安装依赖**</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">项目会生成**node_modules**目录</span><br><span class="line"></span><br><span class="line">我们在在项目终端下(pycharm)运行</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>npm start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">浏览器会自动打开http://localhost:3000运行调试</span><br><span class="line"></span><br><span class="line">## 如何将本地的react项目部署到云服务器上</span><br><span class="line">我们在在项目终端下(pycharm)运行</span><br></pre></td></tr></table></figure>

<p>npm run build</p>
<pre><code>项目会生成了一个**build**目录

打开宝塔服务器页面，到相关网站下，将build页面下==static上传，以及和static平行的文件上传。==

至此，大功告成！
tips:感觉网上的教程大多数很复杂，暂时也不太明白他们做的原理(TODO)</code></pre></div></div><a class="button-hover more" href="2020/02/26/web小项目/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/25/爬虫之selenium报错——Chromedriver/">爬虫之selenium报错——Chromedriver</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-02</time></div><div class="post-content"><div class="main-content content"><p><strong>报错信息：</strong></p>
<figure class="highlight plain"><figcaption><span>executable needs to be in PATH.```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**解决方法：**</span><br><span class="line">### 关于Chromedriver如何配置环境变量问题解决[^1]</span><br><span class="line">到环境变量中加上‪C:\Program Files (x86)\Google\Chrome\Application</span><br><span class="line"></span><br><span class="line">### windows下更新环境变量不需要重启系统快速生效的方法[^2]</span><br></pre></td></tr></table></figure>

<p>set path=test<br>echo %path%<br>```</p>
<h3 id="如果还没有生效的话-3"><a href="#如果还没有生效的话-3" class="headerlink" title="如果还没有生效的话[^3]"></a>如果还没有生效的话[^3]</h3><p><strong>原来还要放到Python目录下</strong><br>很多人都反应上面两步做了也没有生效</p>
<p>最后……<br>自己入自己的坑，才是最绝望的。chromedriver和chrome 多少是眼残的事……</p>
<p>参考：<br>[^1]: <a href="https://blog.csdn.net/qq_41429288/article/details/80472064" target="_blank" rel="noopener">https://blog.csdn.net/qq_41429288/article/details/80472064</a><br>[^2]: <a href="https://blog.csdn.net/u010770041/article/details/49915089" target="_blank" rel="noopener">https://blog.csdn.net/u010770041/article/details/49915089</a><br>[^3]: <a href="https://blog.csdn.net/weixin_37185329/article/details/80493281" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37185329/article/details/80493281</a></p>
</div></div><a class="button-hover more" href="2020/02/25/爬虫之selenium报错——Chromedriver/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/23/ideaVim-easymotion 插件/">ideaVim-easymotion 插件</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-02</time></div><div class="post-content"><div class="main-content content"><h4 id="作用：辅助（优化）ideaVim的"><a href="#作用：辅助（优化）ideaVim的" class="headerlink" title="作用：辅助（优化）ideaVim的"></a>作用：辅助（优化）ideaVim的</h4><p>主要是通过提升了<strong>跳转</strong>方式<br>一般的：<br><code>gg, G</code>最上、最下<br><code>Ctrl-D/U</code>下几步，上几步</p>
<p>网上教程不多，具体更多详细教程：<br><a href="http://www.wklken.me/posts/2015/06/07/vim-plugin-easymotion.html" target="_blank" rel="noopener">http://www.wklken.me/posts/2015/06/07/vim-plugin-easymotion.html</a></p>
</div></div><a class="button-hover more" href="2020/02/23/ideaVim-easymotion 插件/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/22/解决IDEA和Pycharm中Vim插件不能与外界粘贴复制/">解决IDEA和Pycharm中Vim插件不能与外界粘贴复制</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-02</time></div><div class="post-content"><div class="main-content content"><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul>
<li><strong>vim 缓冲区</strong>和<strong>系统剪贴板</strong><br>vim 里面粘贴复制实际上是在vim 缓冲区 存取数据，而系统的ctry+c ctry+v 是与系统剪贴板之间的交互<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3></li>
<li>tools工具下点<strong>vim emulation</strong>，再<strong>重新复制</strong><br>（<em>感觉这的确还是很麻烦，但是暂时没有找到更好的办法了</em>）</li>
</ul>
</div></div><a class="button-hover more" href="2020/02/22/解决IDEA和Pycharm中Vim插件不能与外界粘贴复制/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/20/Java垃圾回收机制/">Java垃圾回收机制</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-30</time></div><div class="post-content"><div class="main-content content"><h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><h2 id="垃圾回收的意义"><a href="#垃圾回收的意义" class="headerlink" title="垃圾回收的意义"></a>垃圾回收的意义</h2><p>在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。<br>事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。</p>
<h3 id="这使Java-虚拟机具有一些优点"><a href="#这使Java-虚拟机具有一些优点" class="headerlink" title="这使Java 虚拟机具有一些优点"></a>这使Java 虚拟机具有一些优点</h3><ul>
<li>首先，它能<strong>使编程效率提高</strong>。在没有垃圾回收机制的时候，可能要花许多时间来解决一个<strong>难懂的存储器问题。</strong></li>
<li>其次是它<strong>保护程序的完整性</strong>（？）， 垃圾回收是Java语言安全性策略的一个重要部份。</li>
</ul>
<h3 id="垃圾回收的一个潜在的缺点是它的开销影响程序性能。"><a href="#垃圾回收的一个潜在的缺点是它的开销影响程序性能。" class="headerlink" title="垃圾回收的一个潜在的缺点是它的开销影响程序性能。"></a>垃圾回收的一个潜在的缺点是它的<strong>开销影响程序性能</strong>。</h3><ul>
<li>Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要<strong>花费处理器的时间。</strong></li>
<li>其次<strong>垃圾回收算法的不完备性</strong>，<em>早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。</em>随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。</li>
</ul>
<h2 id="垃圾收集的算法分析"><a href="#垃圾收集的算法分析" class="headerlink" title="垃圾收集的算法分析"></a>垃圾收集的算法分析</h2><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：<br>**1. 发现无用信息对象</p>
<ol start="2">
<li>回收被无用对象占用的内存空间，使该空间可被程序再次使用。**</li>
</ol>
<blockquote>
<p>大多数垃圾回收算法使用了<strong>根集(root set)</strong>这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃圾回收首先需要确定从根开始 <strong>哪些是可达的和哪些是不可达的</strong>，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。</p>
</blockquote>
<h3 id="1-引用计数法-Reference-Counting-Collector"><a href="#1-引用计数法-Reference-Counting-Collector" class="headerlink" title="1. 引用计数法(Reference Counting Collector)"></a>1. 引用计数法(Reference Counting Collector)</h3><p>引用计数法是<strong>唯一没有使用根集的</strong>垃圾回收的算法，该算法使用引用计数器来区分存活对象和不再使用的对象。堆中的每个对象对应一个引用计数器。<em>计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。</em><br>引用计数算法实现简单，效率很高，微软的COM技术、ActionScript、Python等都使用了引用计数算法进行内存管理，但是引用计数算法对于对象之间相互循环引用问题难以解决，因此java并没有使用引用计数算法。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>基于引用计数器的垃圾收集器运行较<strong>快</strong>，<em>对程序需要不被长时间打断的实时环境比较有利。</em></p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p> <strong>无法检测出循环引用</strong>如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0. 而且每次加减<strong>非常浪费内存</strong>。</p>
<h3 id="2-tracing算法-Tracing-Collector"><a href="#2-tracing算法-Tracing-Collector" class="headerlink" title="2. tracing算法(Tracing Collector)"></a>2. tracing算法(Tracing Collector)</h3><p>tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.</p>
<h3 id="3-compacting算法-Compacting-Collector"><a href="#3-compacting算法-Compacting-Collector" class="headerlink" title="3. compacting算法(Compacting Collector)"></a>3. compacting算法(Compacting Collector)</h3><p>为了<strong>解决堆碎片问题</strong>，基于tracing的垃圾回收吸收了<strong>Compacting算法</strong>的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加<strong>句柄和句柄表</strong>。</p>
<p>标记-整理算法在标记-清除算法基础上做了改进，标记阶段是相同的标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。<br>标记-整理算法相比标记-清除算法的优点是内存<strong>被整理以后不会产生大量不连续内存碎片问题。</strong><br>复制算法在<strong>对象存活率高的情况下</strong>就要执行较多的复制操作，效率将会变低，而在对象存活率高的情况下使用标记-整理算法效率会大大提高。</p>
<h3 id="4-copying（复制）算法-Coping-Collector"><a href="#4-copying（复制）算法-Coping-Collector" class="headerlink" title="4. copying（复制）算法(Coping Collector)"></a>4. copying（复制）算法(Coping Collector)</h3><p>该算法的提出是为了<strong>克服句柄的开销和解决堆碎片的垃圾回收</strong>。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。<br>一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，在对象区与空闲区域的切换过程中，程序暂停执行。</p>
<p>S0和s1将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>可使用的内存降为原来一半。</p>
<p>复制算法用于在<strong>新生代垃圾回收</strong></p>
<h3 id="5-generation（分代收集）算法-Generational-Collector"><a href="#5-generation（分代收集）算法-Generational-Collector" class="headerlink" title="5. generation（分代收集）算法(Generational Collector)"></a>5. generation（分代收集）算法(Generational Collector)</h3><p>stop-and-copy垃圾收集器的一个缺陷是<strong>收集器必须复制所有的活动对象</strong>，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代(generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。</p>
<p>根据内存中对象的存活周期不同，将内存划分为几块，java的虚拟机中一般把内存划分为新生代和年老代，当新创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中，当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。<br>对于新生代和老年代来说,新生代回收频率很高,但是每次回收耗时很短,而老年代回收频率较低,但是耗时会相对较长,所以应该尽量减少老年代的GC.</p>
<h3 id="6-adaptive算法-Adaptive-Collector"><a href="#6-adaptive算法-Adaptive-Collector" class="headerlink" title="6. adaptive算法(Adaptive Collector)"></a>6. adaptive算法(Adaptive Collector)</h3><p>　　在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p>
<h2 id="System-gc-方法"><a href="#System-gc-方法" class="headerlink" title="System.gc()方法"></a>System.gc()方法</h2><p>使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestGC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">　　    <span class="keyword">new</span> TestGC();</span><br><span class="line">　　    System.gc();</span><br><span class="line">　　    System.runFinalization();</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips:调用System.gc()也仅仅是一个<strong>请求(建议)</strong>。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。</p>
<h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h2><p>之所以要使用finalize()，是存在着<strong>垃圾回收器不能处理的特殊情况</strong>。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。</p>
<p>特殊的区域如：</p>
<ol>
<li>由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。</li>
<li>又或者打开的<strong>文件资源</strong>，这些资源不属于垃圾回收器的回收范围。</li>
</ol>
<h2 id="触发主GC（Garbage-Collector）的条件"><a href="#触发主GC（Garbage-Collector）的条件" class="headerlink" title="触发主GC（Garbage Collector）的条件"></a>触发主GC（Garbage Collector）的条件</h2><p>JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。<br>总的来说,有两个条件会触发主GC:</p>
<ol>
<li>当<strong>没有应用线程在运行时</strong>,GC会被调用。因为<strong>GC在优先级最低的线程中进行</strong>,所以当应用忙时,GC线程就不会被调用,但以下条件除外。</li>
<li><strong>Java堆内存不足时</strong>,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,<strong>JVM会再进行两次GC</strong>作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。</li>
</ol>
<h2 id="减少GC开销的措施"><a href="#减少GC开销的措施" class="headerlink" title="减少GC开销的措施"></a>减少GC开销的措施</h2><h3 id="1-不要显式调用System-gc"><a href="#1-不要显式调用System-gc" class="headerlink" title="1. 不要显式调用System.gc()"></a>1. 不要显式调用System.gc()</h3><p> 此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</p>
<h3 id="2-尽量减少临时对象的使用"><a href="#2-尽量减少临时对象的使用" class="headerlink" title="2. 尽量减少临时对象的使用"></a>2. 尽量减少临时对象的使用</h3><p> 临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</p>
<h3 id="3-对象不用时最好显式置为Null"><a href="#3-对象不用时最好显式置为Null" class="headerlink" title="3. 对象不用时最好显式置为Null"></a>3. 对象不用时最好显式置为Null</h3><p> 为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</p>
<h3 id="4-尽量使用StringBuffer-而不用String来累加字符串"><a href="#4-尽量使用StringBuffer-而不用String来累加字符串" class="headerlink" title="4. 尽量使用StringBuffer,而不用String来累加字符串"></a>4. 尽量使用StringBuffer,而不用String来累加字符串</h3><p>  由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</p>
<h3 id="5-能用基本类型如Int-Long-就不用Integer-Long对象"><a href="#5-能用基本类型如Int-Long-就不用Integer-Long对象" class="headerlink" title="5.  能用基本类型如Int,Long,就不用Integer,Long对象"></a>5.  能用基本类型如Int,Long,就不用Integer,Long对象</h3><p>基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</p>
<h3 id="6-尽量少用静态对象变量"><a href="#6-尽量少用静态对象变量" class="headerlink" title="6. 尽量少用静态对象变量"></a>6. 尽量少用静态对象变量</h3><p>静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</p>
<h3 id="7-分散对象创建或删除的时间"><a href="#7-分散对象创建或删除的时间" class="headerlink" title="7. 分散对象创建或删除的时间"></a>7. 分散对象创建或删除的时间</h3><p>集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chair</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">boolean</span> gcrun = <span class="keyword">false</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">boolean</span> f = <span class="keyword">false</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">int</span> created = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">int</span> finalized = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">　　Chair() &#123;</span><br><span class="line">　　    i = ++created;</span><br><span class="line">　　    <span class="keyword">if</span>(created == <span class="number">47</span>)</span><br><span class="line">　　　      System.out.println(<span class="string">"Created 47"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　    <span class="keyword">if</span>(!gcrun) &#123;</span><br><span class="line">　　　      gcrun = <span class="keyword">true</span>;</span><br><span class="line">　　　      System.out.println(<span class="string">"Beginning to finalize after "</span> + created + <span class="string">" Chairs have been created"</span>);</span><br><span class="line">　　    &#125;</span><br><span class="line">　　    <span class="keyword">if</span>(i == <span class="number">47</span>) &#123;</span><br><span class="line">　　　      System.out.println(<span class="string">"Finalizing Chair #47， "</span> +<span class="string">"Setting flag to stop Chair creation"</span>);</span><br><span class="line">　　　      f = <span class="keyword">true</span>;</span><br><span class="line">　　    &#125;</span><br><span class="line">　　    finalized++;</span><br><span class="line">　　    <span class="keyword">if</span>(finalized &gt;= created)</span><br><span class="line">　　　      System.out.println(<span class="string">"All "</span> + finalized + <span class="string">" finalized"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Garbage</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span>(args.length == <span class="number">0</span>) &#123;</span><br><span class="line">　　　  System.err.println(<span class="string">"Usage: /n"</span> + <span class="string">"java Garbage before/n or:/n"</span> + <span class="string">"java Garbage after"</span>);</span><br><span class="line">　　　  <span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">while</span>(!Chair.f) &#123;</span><br><span class="line">　　　  <span class="keyword">new</span> Chair();</span><br><span class="line">　　　  <span class="keyword">new</span> String(<span class="string">"To take up space"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　System.out.println(<span class="string">"After all Chairs have been created:/n"</span> + <span class="string">"total created = "</span> + Chair.created +</span><br><span class="line">　　<span class="string">"， total finalized = "</span> + Chair.finalized);</span><br><span class="line">　　<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"before"</span>)) &#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"gc():"</span>);</span><br><span class="line">　　　　System.gc();</span><br><span class="line">　　　　System.out.println(<span class="string">"runFinalization():"</span>);</span><br><span class="line">　　　　System.runFinalization();</span><br><span class="line">　　&#125;</span><br><span class="line">　　System.out.println(<span class="string">"bye!"</span>);</span><br><span class="line">　　<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"after"</span>))</span><br><span class="line">　　　  System.runFinalizersOnExit(<span class="keyword">true</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这个程序创建了许多Chair对象，而且在垃圾收集器开始运行后的某些时候，程序会停止创建Chair。由于垃圾收集器可能在任何时间运行，所以我们不能准确知道它在何时启动。因此，程序用一个名为gcrun的标记来指出垃圾收集器是否已经开始运行。利用第二个标记f，Chair可告诉main()它应停止对象的生成。这两个标记都是在finalize()内部设置的，它调用于垃圾收集期间。另两个static变量–created以及 finalized–分别用于跟踪已创建的对象数量以及垃圾收集器已进行完收尾工作的对象数量。最后，每个Chair都有它自己的（非 static）int i，所以能跟踪了解它具体的编号是多少。编号为47的Chair进行完收尾工作后，标记会设为true，最终结束Chair对象的创建过程。</p>
</blockquote>
<h2 id="关于垃圾回收的几点补充"><a href="#关于垃圾回收的几点补充" class="headerlink" title="关于垃圾回收的几点补充"></a>关于垃圾回收的几点补充</h2><ul>
<li>垃圾收集发生的<strong>不可预知性</strong>：由于实现了不同的垃圾回收算法和采用了不同的收集机制，所以它有可能是定时发生，有可能是当出现系统空闲CPU资源时发生，也有可能是和原始的垃圾收集一样，等到内存消耗出现极限时发生，这与垃圾收集器的选择和具体的设置都有关系。</li>
<li>垃圾收集的实现和<strong>具体的JVM 以及JVM的内存模型</strong>有非常紧密的关系。不同的JVM 可能采用不同的垃圾收集，而<strong>JVM 的内存模型决定着该JVM可以采用哪些类型垃圾收集</strong>。现在，<strong>HotSpot 系列</strong>JVM中的内存系统都采用先进的面向对象的框架设计，这使得该系列JVM都可以采用最先进的垃圾收集。</li>
<li><strong>尽早释放无用对象的引用。</strong>大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的<strong>对象是否被监听</strong>，如果有，则要<strong>去掉监听器，然后再赋空值</strong>。</li>
<li>关键的也是难把握的问题是<strong>内存泄漏</strong>。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。</li>
</ul>
<p>博客参考：<br><a href="https://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="noopener">https://blog.csdn.net/zsuguangh/article/details/6429592</a><br><a href="https://blog.csdn.net/zhangcongyi420/article/details/89060970" target="_blank" rel="noopener">https://blog.csdn.net/zhangcongyi420/article/details/89060970</a></p>
</div></div><a class="button-hover more" href="2020/02/20/Java垃圾回收机制/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/19/leetcode数组类/">leetcode之数组类</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><p><em>使用C/C++做法</em></p>
<h3 id="主要元素"><a href="#主要元素" class="headerlink" title="主要元素"></a>主要元素</h3><p><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-majority-element-lcci/</a></p>
<p>快排</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i + k &lt; numsSize ;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] == nums[i+k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超时</p>
<blockquote>
<p><strong>摩尔投票算法</strong>是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。<br>核心就是<strong>对拼消耗</strong>。<br>知乎讲解：<a href="https://www.zhihu.com/question/49973163" target="_blank" rel="noopener">https://www.zhihu.com/question/49973163</a></p>
</blockquote>
<h2 id="消失的数字"><a href="#消失的数字" class="headerlink" title="消失的数字"></a>消失的数字</h2><p><a href="https://leetcode-cn.com/problems/missing-number-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/missing-number-lcci/</a></p>
<blockquote>
<p>M：<br>构建一个辅助数组，遇到了就是0，没有遇到就是1，最后再找到那个值</p>
</blockquote>
<ol>
<li><p>第一种方法：<br>1）计算总和<br>2）用数列公式 - 总和</p>
</li>
<li><p>第二种方法：<br>1）边加边减</p>
</li>
</ol>
<h2 id="合并排序的数组"><a href="#合并排序的数组" class="headerlink" title="合并排序的数组"></a>合并排序的数组</h2><p><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sorted-merge-lcci/</a></p>
<blockquote>
<p>方法 1: 直接合并后排序<br>方法 2: 双指针<br>方法3：逆向双指针 （不需要额外开辟空间，但前提是前一个的容量要足够大）</p>
</blockquote>
<h2 id="连续数列"><a href="#连续数列" class="headerlink" title="连续数列"></a>连续数列</h2><p><a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contiguous-sequence-lcci/</a></p>
<blockquote>
<p>题的关键是要理解这么一层含义：对于数组 nums = [5, -9, 6, -2, 3]，5 是否要加 -9，取决于 -9 后面的正数是否能抵消 -9 并还有剩余。<br>一般称这种为贪心问题</p>
</blockquote>
<p><strong>动态规划</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.length;i++)&#123;</span><br><span class="line">			<span class="comment">//b = b&lt;0? nums[i]:b+nums[i];</span></span><br><span class="line">            <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                b=nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b&gt;sum)&#123;</span><br><span class="line">                sum=b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分治算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分治法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    <span class="keyword">return</span> divide(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 1. 最大数列和在左边</span></span><br><span class="line">    <span class="keyword">int</span> sumLeft = divide(nums,left,mid);</span><br><span class="line">    <span class="comment">// 2. 最大数列和在右边</span></span><br><span class="line">    <span class="keyword">int</span> sumRight = divide(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="comment">// 3. 最大数列和在中间</span></span><br><span class="line">    <span class="comment">// 先求左边的最大和</span></span><br><span class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>,leftMaxSum = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= left; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">        leftMaxSum = max(leftMaxSum,leftSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求右边的最大和</span></span><br><span class="line">    <span class="keyword">int</span> rightSum = <span class="number">0</span>,rightMaxSum = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rightSum += nums[i];</span><br><span class="line">        rightMaxSum = max(rightMaxSum,rightSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(max(sumLeft,sumRight),leftMaxSum+rightMaxSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在排序数组中查找数字-I"><a href="#在排序数组中查找数字-I" class="headerlink" title="在排序数组中查找数字 I"></a>在排序数组中查找数字 I</h2><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</a></p>
<p><strong>二分查找法找到第一次出现的位置和最后一次出现的位置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span>; j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="2020/02/19/leetcode数组类/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/18/递归思想&amp;递归转化成非递归/">递归思想&amp;递归转化成非递归</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h2 id="递归理解"><a href="#递归理解" class="headerlink" title="递归理解"></a>递归理解</h2><p><em>递归思想</em>就是：<strong>把问题分解成规模更小，但和原问题有着相同解法的问题。</strong><br><em>典型的问题</em>有<strong>汉诺塔问题，斐波那契数列，二分查找问题，快速排序问题</strong>等。<br>其实像我们常见的<strong>分治法和动态规划法</strong>都是递归思想的经典应用。</p>
<p><strong>最关键的：</strong><br>存在一个能让递归调用退出的<strong>出口</strong>。</p>
<h2 id="递归、循环、迭代、遍历的区别"><a href="#递归、循环、迭代、遍历的区别" class="headerlink" title="递归、循环、迭代、遍历的区别"></a>递归、循环、迭代、遍历的区别</h2><ul>
<li>递归：一个函数反复调用自身的行为，特指函数本身；</li>
<li>循环：满足一定条件下，重复执行某些行为，如while结构；</li>
<li>迭代：按某种规则执行一个序列中的每一项，如for结构；</li>
<li>遍历：按某种规则访问图形结构中每一个节点，特指图形结构。</li>
</ul>
<h2 id="递归过程初分析"><a href="#递归过程初分析" class="headerlink" title="递归过程初分析"></a>递归过程初分析</h2><p>在大多数机器上，每次调用函数时大致要做三个工作：调用前先<strong>保存寄存器</strong>，并在返回时恢复；复制实参；程序必须转向一个新位置执行。<br>其中，具体要保存的内容包括：局部变量、形参、调用函数地址、返回值。那么，如果递归调用N次，就要分配N<em>局部变量、N</em>形参、N<em>调用函数地址、N</em>返回值。这势必是影响效率的。</p>
<h2 id="递归转非递归的方法"><a href="#递归转非递归的方法" class="headerlink" title="递归转非递归的方法"></a>递归转非递归的方法</h2><ol>
<li>第一种情况：<strong>递归转尾递归</strong>的问题，这类问题可以不借助堆栈结构将递归转化为循环结构。</li>
<li>第二种情况：借助堆栈将递归转化为非递归（PS：任何递归都可以借助堆栈转化成非递归，第一种情况严格意义上来说不能看做是一种情况）。<br>其中，第二种情况又可以进一步分为两种转化方法：<ol>
<li>第一种方法：<strong>借助堆栈模拟递归的执行过程。</strong>这种方法几乎是<strong>通用</strong>的方法，因为递归本身就是通过堆栈实现的，我们只要把递归函数调用的局部变量和相应的状态放入到一个栈结构中，在函数调用和返回时做好push和pop操作，就可以了（<strong>模拟快排</strong>的例子）。</li>
<li>第二种方法：借助堆栈的循环结构算法。这种方法常常适用于某些局部变量有依赖关系，且需要重复执行的场景，例如<strong>二叉树的遍历算法</strong>，就采用的这种方法。</li>
</ol>
</li>
</ol>
<p><em>延伸问题:</em><br>在斐波那契数列中，如果兔子永远不死，一直繁衍下去，则怎么解？很明显，这是个大数问题。</p>
<p>参考：<br><a href="https://www.cnblogs.com/bakari/p/5349383.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/5349383.html</a></p>
</div></div><a class="button-hover more" href="2020/02/18/递归思想&amp;递归转化成非递归/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/17/pandas读取excel/">pandas读取excel</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h4 id="pandas处理excel数据非常便捷"><a href="#pandas处理excel数据非常便捷" class="headerlink" title="pandas处理excel数据非常便捷"></a>pandas处理excel数据非常便捷</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">r'F:\C\train_01.xlsx'</span>)</span><br><span class="line">data=df.loc[:,[<span class="string">'留言详情'</span>,<span class="string">'一级分类'</span>]].values<span class="comment">#读所有行的title以及data列的值，这里需要嵌套列表</span></span><br><span class="line"><span class="comment"># data=df.loc[:,['留言详情']].values</span></span><br><span class="line">print(<span class="string">"读取指定行的数据：\n&#123;0&#125;"</span>.format(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'numpy.ndarray'&gt; 将此转化成列表</span></span><br><span class="line">x = df.stack().tolist()</span><br><span class="line"></span><br><span class="line">data_01=[]</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> x:</span><br><span class="line">    sentence = line.strip().replace(<span class="string">u'\u3000'</span>, <span class="string">u' '</span>).replace(<span class="string">u'\xa0'</span>, <span class="string">u' '</span>).replace(<span class="string">" "</span>, <span class="string">""</span>).replace(<span class="string">"\r"</span>, <span class="string">""</span>).replace(<span class="string">"\n"</span>, <span class="string">""</span>)</span><br><span class="line">    data_01.append(sentence) </span><br><span class="line">    </span><br><span class="line"><span class="comment"># \u3000 是全角的空白符</span></span><br><span class="line"><span class="comment"># 终于把\n和\r给换掉了</span></span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="2020/02/17/pandas读取excel/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="page-number" href="page/3/">3</a><a class="extend next" rel="next" href="page/2/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Rr-shan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>