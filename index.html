<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Rr-shan,undefined"><meta name="copyright" content="Rr-shan"><title>【Sanzzi】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Rr-shan</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Rr-shan" target="_blank">GitHub<i class="icon-dot bg-color6"></i></a><a class="links-button button-hover" href="mailto:1224559633@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color9"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">21</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Sanzzi</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2020/03/29/srf之论文汇报流程/">srf之论文汇报流程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h2 id="论文将要讲述的方面"><a href="#论文将要讲述的方面" class="headerlink" title="论文将要讲述的方面"></a>论文将要讲述的方面</h2><ol>
<li>为什么要讲这个?（背景）</li>
<li>提出了什么 <strong>方法</strong> ?</li>
<li>传统方法有什么问题?（<strong>对比</strong>）</li>
<li><strong>原理</strong>简单讲一讲（数学方面要求不是很高，有代码实现更方便）?</li>
<li><strong>数据集</strong>是怎么<strong>划分</strong>的?</li>
<li><strong>交叉验证</strong>怎么做?</li>
</ol>
<h2 id="研究方法和主题"><a href="#研究方法和主题" class="headerlink" title="研究方法和主题"></a>研究方法和主题</h2><p>学长说在GCN方面不会有更深入的探寻了，会在以下几个方面找突破口</p>
<ul>
<li>Attention机制</li>
<li>知识图谱</li>
<li>异构图网络的学习</li>
<li>嵌入式学习</li>
</ul>
<h2 id="论文的选取"><a href="#论文的选取" class="headerlink" title="论文的选取"></a>论文的选取</h2><blockquote>
<p><strong>新</strong>（前沿），在期刊上发表的更好<br>有代码最好，有名字的模型在github上可以搜索的到</p>
</blockquote>
<h2 id="学长目前的想法"><a href="#学长目前的想法" class="headerlink" title="学长目前的想法"></a>学长目前的想法</h2><ul>
<li>SMILES收集之后：通过label encoding提取smiles的embedding<br><img src="srf%E4%B9%8B%E8%AE%BA%E6%96%87%E6%B1%87%E6%8A%A5%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></li>
</ul>
</div></div><a class="button-hover more" href="/2020/03/29/srf之论文汇报流程/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/26/web小项目/">Web小项目(react调试和部署)</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h2 id="如何在本地调试react项目"><a href="#如何在本地调试react项目" class="headerlink" title="如何在本地调试react项目"></a>如何在本地调试react项目</h2><blockquote>
<p>在项目终端下(pycharm)运行 <figure class="highlight plain"><figcaption><span>install```**安装依赖**</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">项目会生成**node_modules**目录</span><br><span class="line"></span><br><span class="line">我们在在项目终端下(pycharm)运行</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>npm start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">浏览器会自动打开http://localhost:3000运行调试</span><br><span class="line"></span><br><span class="line">## 如何将本地的react项目部署到云服务器上</span><br><span class="line">我们在在项目终端下(pycharm)运行</span><br></pre></td></tr></table></figure>

<p>npm run build</p>
<pre><code>项目会生成了一个**build**目录

打开宝塔服务器页面，到相关网站下，将build页面下==static上传，以及和static平行的文件上传。==

至此，大功告成！
tips:感觉网上的教程大多数很复杂，暂时也不太明白他们做的原理(TODO)</code></pre></div></div><a class="button-hover more" href="/2020/02/26/web小项目/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/15/springcloud/">SpringCloud</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><p>纯洁的微笑关于springcloud的知识是2017年的</p>
<p>在使用了一段时间后发现Spring Cloud从技术架构上降低了对大型系统构建的要求，使我们以非常低的成本（技术或者硬件）搭建一套高效、分布式、容错的平台，但Spring Cloud也不是没有缺点，小型独立的项目不适合使用。</p>
<p>Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<ol>
<li>大话Spring Cloud 核心成员的介绍</li>
</ol>
<p>目前，国内使用 Spring Cloud 技术的公司并不多见，不是因为 Spring Cloud 不好，主要原因有以下几点：</p>
<ol>
<li>Spring Cloud 中文文档较少，出现问题网上没有太多的解决方案。</li>
<li>国内创业型公司技术老大大多是阿里系员工，而阿里系多采用 Dubbo 来构建微服务架构。（阿里已经采用了）</li>
<li>大型公司基本都有自己的分布式解决方案，而中小型公司的架构很多用不上微服务，所以没有采用 Spring Cloud 的必要性。</li>
</ol>
</div></div><a class="button-hover more" href="/2020/02/15/springcloud/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/14/shortUrl/">Springboot实战项目——短链接设计</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><hr>
<p>短链接的生成，可以有两种方法。<br>第一种，直接调用百度API一类网址生成短链接<br>第二种，当我们生成短链接之后，只需要在表中（数据库或者NoSql ）存储原始链接与短链接的<strong>映射关系</strong>即可。当我们访问短链接时，只需要从映射关系中找到原始链接，即可跳转到原始链接。</p>
<h2 id="SpringBoot连接Mysql数据库"><a href="#SpringBoot连接Mysql数据库" class="headerlink" title="SpringBoot连接Mysql数据库"></a>SpringBoot连接Mysql数据库</h2><blockquote>
<p>　Spring连接Mysql的方式有很多，例如JDBC，Spring JPA，Hibeirnate，Mybatis等</p>
</blockquote>
<h4 id="JDBC依赖导入"><a href="#JDBC依赖导入" class="headerlink" title="JDBC依赖导入"></a>JDBC依赖导入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置数据库的文件"><a href="#配置数据库的文件" class="headerlink" title="配置数据库的文件"></a>配置数据库的文件</h4><p>(喜欢yml)</p>
<ul>
<li><p>application.properties</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url: jdbc:mysql://127.0.0.1:3306/DataName?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT</span><br><span class="line">spring.datasource.username:root</span><br><span class="line">spring.datasource.password:root</span><br><span class="line">spring.datasource.driver-class-name:com.mysql.jdbc</span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#   数据源基本配置</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="attr">dbc:mysql://192.168.26.128:3306/Mybatis?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>1.创建数据库（shorturl），创建一个表，存储长链接和与之对应的短链接；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`link`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`long_url`</span> <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'长链接'</span>,</span><br><span class="line">  <span class="string">`short_url`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'短链接'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- AUTO_INCREMENT 自增 AUTO_INCREMENT=1 从开始增加</span></span><br><span class="line"><span class="comment">-- PRIMAPY是主键的意思，表示定义的该列值在表中是唯一的意思，不可以有重复。</span></span><br><span class="line"><span class="comment">-- ENGINE InnoDB锁定表中的特定行，并MyISAM锁定整个MySQL表。</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="连接虚拟机的数据库"><a href="#连接虚拟机的数据库" class="headerlink" title="连接虚拟机的数据库"></a>连接虚拟机的数据库</h2><h3 id="查看电脑的IP地址"><a href="#查看电脑的IP地址" class="headerlink" title="查看电脑的IP地址"></a>查看电脑的IP地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>

<p>192.168.26.128</p>
<h4 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 名字 建表 </span><br><span class="line"><span class="keyword">use</span> 数据库名; //到达某一数据库</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; //列出所有表</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">link</span>(<span class="keyword">id</span>,long_url,short_url)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">'1'</span>,<span class="string">'https://jingyan.baidu.com/article/ca41422f0be18e1eae99ed15.html'</span>,<span class="string">'Abj876'</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p>查看前端向后台发送的请求:F12 -&gt; network -&gt; XHR</p>
<h3 id="懒人站长"><a href="#懒人站长" class="headerlink" title="懒人站长"></a>懒人站长</h3><p><a href="http://www.ab173.com/zhanzhang/getheader.php" target="_blank" rel="noopener">http://www.ab173.com/zhanzhang/getheader.php</a><br>查看网页HTTP状态代码检测<br>测试<br>新浪网址（永久短网址） 查不出状态码<br>百度短网址 返回302<br>加密短网址 返回302<br>腾讯短网址 返回302</p>
<h4 id="get和post请求"><a href="#get和post请求" class="headerlink" title="get和post请求"></a>get和post请求</h4><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<blockquote>
<p>HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p>
</blockquote>
<blockquote>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。<br>参考博客：<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener">https://www.cnblogs.com/logsharing/p/8448446.html</a><br>风格挺有意思的</p>
</blockquote>
<h3 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h3><h5 id="映射实体类的数据类型"><a href="#映射实体类的数据类型" class="headerlink" title="映射实体类的数据类型"></a>映射实体类的数据类型</h5><p>resultMap: 唯一标识<br>column: 库表的字段名<br>property： 实体类里的属性名</p>
<p>配置映射文件：(摘自网络)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace:当前库表映射文件的命名空间，唯一的不能重复 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.hao947.sql.mapper.PersonMapper"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- type:映射实体类的数据类型 id：resultMap的唯一标识 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"person"</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- column:库表的字段名 property:实体类里的属性名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"person_id"</span> <span class="attr">property</span>=<span class="string">"personId"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"person_addr"</span> <span class="attr">property</span>=<span class="string">"personAddr"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"birthday"</span> <span class="attr">property</span>=<span class="string">"birthday"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--id:当前sql的唯一标识</span></span><br><span class="line"><span class="comment">     parameterType：输入参数的数据类型 </span></span><br><span class="line"><span class="comment">     resultType：返回值的数据类型 </span></span><br><span class="line"><span class="comment">     #&#123;&#125;:用来接受参数的，如果是传递一个参数#&#123;id&#125;内容任意，如果是多个参数就有一定的规则,采用的是预编译的形式select </span></span><br><span class="line"><span class="comment">    * from person p where p.id = ? ，安全性很高 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>yml文件的key与value之间必须至少空一空格</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">mapper-locations:</span> <span class="attr">classpath:mapper/*.xml</span></span><br><span class="line"><span class="comment"># it is forbidden to  specify block composed value at the same line as key classpath后面不能空格</span></span><br></pre></td></tr></table></figure>

<h5 id="Maven与Gradle的对比"><a href="#Maven与Gradle的对比" class="headerlink" title="Maven与Gradle的对比"></a>Maven与Gradle的对比</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span>(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-web"</span>) &#123;</span><br><span class="line">        <span class="keyword">exclude</span> module: <span class="string">"spring-boot-starter-tomcat"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-security"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-data-jpa"</span>)</span><br><span class="line">    testCompile(<span class="string">"mysql:mysql-connector-java:5.1.25"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细阅读下你会发现，原来是依赖管理所需的配置长度变短了。在pom.xml中我们需要引入一个依赖时需要将它的groupId, artifactId和version都用标签引起来。但是在build.gradle中你会发现，仅仅需要将三者的value用:连起来，并”调用compile函数”就可以啦。</p>
<p>这个是记录操作路上的磕磕盼盼，参考价值可能不大。</p>
</div></div><a class="button-hover more" href="/2020/02/14/shortUrl/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/14/NLP入门之文本分类/">NLP入门之文本分类</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlrd <span class="comment"># 也可以使用pandas处理excel，非常好用</span></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">r'F:\C_1\train\train.xlsx'</span>)</span><br><span class="line">sheet = workbook.sheet_by_index(<span class="number">0</span>) <span class="comment"># sheet索引从0开始</span></span><br><span class="line">cols_1 = sheet.col_values(<span class="number">4</span>) <span class="comment"># 获取第3列内容</span></span><br><span class="line">cols_2 = sheet.col_values(<span class="number">5</span>)</span><br><span class="line">X_train = cols_1</span><br><span class="line">y_train = cols_2</span><br><span class="line"></span><br><span class="line">workbook1 = xlrd.open_workbook(<span class="string">r'F:\C_1\test\test.xlsx'</span>)</span><br><span class="line">sheet = workbook1.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">cols_3 = sheet.col_values(<span class="number">4</span>)</span><br><span class="line">cols_4 = sheet.col_values(<span class="number">5</span>)</span><br><span class="line">X_test = cols_3</span><br><span class="line">y_test = cols_4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉空格</span></span><br><span class="line">X_train_word = [jieba.cut(words) <span class="keyword">for</span> words <span class="keyword">in</span> X_train]</span><br><span class="line">X_train_cut = [<span class="string">' '</span>.join(word) <span class="keyword">for</span> word <span class="keyword">in</span> X_train_word]</span><br><span class="line">X_test_word = [jieba.cut(words) <span class="keyword">for</span> words <span class="keyword">in</span> X_test]</span><br><span class="line">X_test_cut  = [<span class="string">' '</span>.join(word) <span class="keyword">for</span> word <span class="keyword">in</span> X_test_word]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 停止词使用</span></span><br><span class="line">stoplist = [word.strip() <span class="keyword">for</span> word <span class="keyword">in</span> open(<span class="string">'F:\MLstudy\stop\stopword.txt'</span>, \</span><br><span class="line">                                           encoding=<span class="string">'utf-8'</span>).readlines()]</span><br><span class="line"><span class="comment"># from sklearn.preprocessing import LabelEncoder</span></span><br><span class="line">le = LabelEncoder()</span><br><span class="line">y_train_le = le.fit_transform(y_train)</span><br><span class="line">y_test_le  = le.fit_transform(y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment">#文本数据转换成数据值数据矩阵</span></span><br><span class="line"><span class="comment"># from sklearn.feature_extraction.text import CountVectorizer</span></span><br><span class="line">count = CountVectorizer(stop_words=stoplist)</span><br><span class="line"></span><br><span class="line">count.fit(list(X_train_cut) + list(X_test_cut))</span><br><span class="line">X_train_count = count.transform(X_train_cut)</span><br><span class="line">X_test_count  = count.transform(X_test_cut)</span><br><span class="line"></span><br><span class="line">X_train_count = X_train_count.toarray()</span><br><span class="line">X_test_count  = X_test_count.toarray()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存储所有算法的名字，准确率和所消耗的时间</span></span><br><span class="line">estimator_list, score_list, time_list = [], [], []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_text_classification</span><span class="params">(estimator, X, y, X_test, y_test)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    estimator: 分类器，必选参数</span></span><br><span class="line"><span class="string">            X: 特征训练数据，必选参数</span></span><br><span class="line"><span class="string">            y: 标签训练数据，必选参数</span></span><br><span class="line"><span class="string">       X_test: 特征测试数据，必选参数</span></span><br><span class="line"><span class="string">        y_tes: 标签测试数据，必选参数</span></span><br><span class="line"><span class="string">       return: 返回值</span></span><br><span class="line"><span class="string">           y_pred_model: 预测值</span></span><br><span class="line"><span class="string">             classifier: 分类器名字</span></span><br><span class="line"><span class="string">                  score: 准确率</span></span><br><span class="line"><span class="string">                      t: 消耗的时间</span></span><br><span class="line"><span class="string">                  matrix: 混淆矩阵</span></span><br><span class="line"><span class="string">                  report: 分类评价函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法正在启动，请稍候...'</span>)</span><br><span class="line">    model = estimator</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法正在进行训练，请稍候...'</span>)</span><br><span class="line">    model.fit(X, y)</span><br><span class="line">    print(model)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法正在进行预测，请稍候...'</span>)</span><br><span class="line">    y_pred_model = model.predict(X_test)</span><br><span class="line">    print(y_pred_model)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法正在进行性能评估，请稍候...'</span>)</span><br><span class="line">    score = metrics.accuracy_score(y_test, y_pred_model)</span><br><span class="line">    matrix = metrics.confusion_matrix(y_test, y_pred_model)</span><br><span class="line">    report = metrics.classification_report(y_test, y_pred_model)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#     f1 = metrics.f1_score(y_test, y_pred_model,average='weighted') #这是加权的</span></span><br><span class="line">    f1 = metrics.f1_score(y_test, y_pred_model, average=<span class="string">'macro'</span>)</span><br><span class="line">    print(<span class="string">'&gt;&gt;&gt;准确率\n'</span>, score)</span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;混淆矩阵\n'</span>, matrix)</span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;召回率\n'</span>, report)</span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;F1 score\n'</span>, f1)</span><br><span class="line">    print(<span class="string">'&gt;&gt;&gt;算法程序已经结束...'</span>)</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    t = end - start</span><br><span class="line">    print(<span class="string">'\n&gt;&gt;&gt;算法消耗时间为：'</span>, t, <span class="string">'秒\n'</span>)</span><br><span class="line">    classifier = str(model).split(<span class="string">'('</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_pred_model, classifier, score, round(t, <span class="number">2</span>), matrix, report</span><br></pre></td></tr></table></figure>

<h2 id="方法1——k-近邻算法"><a href="#方法1——k-近邻算法" class="headerlink" title="方法1——k 近邻算法"></a>方法1——k 近邻算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">knc = KNeighborsClassifier()</span><br><span class="line">result = get_text_classification(knc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法2——决策树"><a href="#方法2——决策树" class="headerlink" title="方法2——决策树"></a>方法2——决策树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">dtc = DecisionTreeClassifier()</span><br><span class="line">result = get_text_classification(dtc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法3——多层感知器"><a href="#方法3——多层感知器" class="headerlink" title="方法3——多层感知器"></a>方法3——多层感知器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line"></span><br><span class="line">mlpc = MLPClassifier()</span><br><span class="line">result = get_text_classification(mlpc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法4——伯努力贝叶斯算法"><a href="#方法4——伯努力贝叶斯算法" class="headerlink" title="方法4——伯努力贝叶斯算法"></a>方法4——伯努力贝叶斯算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> BernoulliNB</span><br><span class="line"></span><br><span class="line">bnb = BernoulliNB()</span><br><span class="line">result = get_text_classification(bnb, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法5——高斯贝叶斯"><a href="#方法5——高斯贝叶斯" class="headerlink" title="方法5——高斯贝叶斯"></a>方法5——高斯贝叶斯</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line">gnb = GaussianNB()</span><br><span class="line">result = get_text_classification(gnb, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法6——多项式朴素贝叶斯"><a href="#方法6——多项式朴素贝叶斯" class="headerlink" title="方法6——多项式朴素贝叶斯"></a>方法6——多项式朴素贝叶斯</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"></span><br><span class="line">mnb = MultinomialNB()</span><br><span class="line">result = get_text_classification(mnb, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法7——逻辑回归算法"><a href="#方法7——逻辑回归算法" class="headerlink" title="方法7——逻辑回归算法"></a>方法7——逻辑回归算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">lgr = LogisticRegression()</span><br><span class="line">result = get_text_classification(lgr, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="方法8——支持向量机算法"><a href="#方法8——支持向量机算法" class="headerlink" title="方法8——支持向量机算法"></a>方法8——支持向量机算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line">svc = svm.SVC()</span><br><span class="line">result = get_text_classification(svc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="集成学习算法——方法1——随机森林算法"><a href="#集成学习算法——方法1——随机森林算法" class="headerlink" title="集成学习算法——方法1——随机森林算法"></a>集成学习算法——方法1——随机森林算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line">rfc = RandomForestClassifier()</span><br><span class="line">result = get_text_classification(rfc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="集成学习算法——方法2——自增强算法"><a href="#集成学习算法——方法2——自增强算法" class="headerlink" title="集成学习算法——方法2——自增强算法"></a>集成学习算法——方法2——自增强算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"></span><br><span class="line">abc = AdaBoostClassifier()</span><br><span class="line">result = get_text_classification(abc, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="集成学习算法——方法3——lightgbm算法"><a href="#集成学习算法——方法3——lightgbm算法" class="headerlink" title="集成学习算法——方法3——lightgbm算法"></a>集成学习算法——方法3——lightgbm算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lightgbm</span><br><span class="line"></span><br><span class="line">gbm = lightgbm.LGBMClassifier()</span><br><span class="line">result = get_text_classification(gbm, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="集成学习算法——方法4——xgboost算法"><a href="#集成学习算法——方法4——xgboost算法" class="headerlink" title="集成学习算法——方法4——xgboost算法"></a>集成学习算法——方法4——xgboost算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost</span><br><span class="line"></span><br><span class="line">xgb = xgboost.XGBClassifier()</span><br><span class="line">result = get_text_classification(xgb, X_train_count, y_train_le, X_test_count, y_test_le)</span><br><span class="line">estimator_list.append(result[<span class="number">1</span>]), score_list.append(result[<span class="number">2</span>]), time_list.append(result[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="深度学习算法——方法1——多分类前馈神经网络"><a href="#深度学习算法——方法1——多分类前馈神经网络" class="headerlink" title="深度学习算法——方法1——多分类前馈神经网络"></a>深度学习算法——方法1——多分类前馈神经网络</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> keras.utils.np_utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="comment"># --------------------------------</span></span><br><span class="line"><span class="comment"># np.random.seed(0)     # 设置随机数种子</span></span><br><span class="line">feature_num = X_train_count.shape[<span class="number">1</span>]     <span class="comment"># 设置所希望的特征数量</span></span><br><span class="line"><span class="comment"># print(feature_num)</span></span><br><span class="line"><span class="comment"># ---------------------------------</span></span><br><span class="line"><span class="comment"># 独热编码目标向量来创建目标矩阵</span></span><br><span class="line">y_train_cate = to_categorical(y_train_le)</span><br><span class="line">y_test_cate = to_categorical(y_test_le)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 1 创建神经网络</span></span><br><span class="line">network = models.Sequential() </span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 2 添加神经连接层</span></span><br><span class="line"><span class="comment"># 第一层必须有并且一定是 [输入层], 必选</span></span><br><span class="line">network.add(layers.Dense(     <span class="comment"># 添加带有 relu 激活函数的全连接层</span></span><br><span class="line">                         units=<span class="number">128</span>, </span><br><span class="line">                         activation=<span class="string">'relu'</span>, </span><br><span class="line">                         input_shape=(feature_num, )</span><br><span class="line">                         ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 介于第一层和最后一层之间的称为 [隐藏层]，可选</span></span><br><span class="line">network.add(layers.Dense(     <span class="comment"># 添加带有 relu 激活函数的全连接层</span></span><br><span class="line">                         units=<span class="number">128</span>, </span><br><span class="line">                         activation=<span class="string">'relu'</span></span><br><span class="line">                         ))</span><br><span class="line">network.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line"><span class="comment"># network.add(layers.Dropout(0.4))</span></span><br><span class="line"><span class="comment"># 最后一层必须有并且一定是 [输出层], 必选                         </span></span><br><span class="line">network.add(layers.Dense(     <span class="comment"># 添加带有 softmax 激活函数的全连接层</span></span><br><span class="line">                         units=<span class="number">8</span>,</span><br><span class="line">                         activation=<span class="string">'sigmoid'</span></span><br><span class="line">                         ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 3 编译神经网络</span></span><br><span class="line">network.compile(loss=<span class="string">'categorical_crossentropy'</span>,  <span class="comment"># 分类交叉熵损失函数    </span></span><br><span class="line">                optimizer=<span class="string">'rmsprop'</span>,  </span><br><span class="line">                metrics=[<span class="string">'accuracy'</span>]              <span class="comment"># 准确率度量</span></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 4 开始训练神经网络</span></span><br><span class="line">history = network.fit(X_train_count,     <span class="comment"># 训练集特征</span></span><br><span class="line">            y_train_cate,        <span class="comment"># 训练集标签</span></span><br><span class="line">            epochs=<span class="number">20</span>,          <span class="comment"># 迭代次数</span></span><br><span class="line">            batch_size=<span class="number">300</span>,    <span class="comment"># 每个批量的观测数  可做优化</span></span><br><span class="line">            validation_data=(X_test_count, y_test_cate)  <span class="comment"># 验证测试集数据</span></span><br><span class="line">            )</span><br><span class="line">network.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># 6 性能评估</span></span><br><span class="line">print(<span class="string">'&gt;&gt;&gt;多分类前馈神经网络性能评估如下...\n'</span>)</span><br><span class="line">score = network.evaluate(X_test_count,</span><br><span class="line">                        y_test_cate,</span><br><span class="line">                        batch_size=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n&gt;&gt;&gt;评分\n'</span>, score)</span><br><span class="line">print()</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line">estimator_list.append(<span class="string">'前馈网络'</span>)</span><br><span class="line">score_list.append(score[<span class="number">1</span>])</span><br><span class="line">time_list.append(round(end-start, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="/2020/02/14/NLP入门之文本分类/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/13/Python词云/">Python词云</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-02-14</time></div><div class="post-content"><div class="main-content content"><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy matplotlib pillow wordcloud imageio jieba snownlp itchat -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>用清华的镜像速度好评</p>
<p>网上提供的图片素材太少了，只好用自己一般的画工作图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入imageio库中的imread函数，并用这个函数读取本地图片，作为词云形状图片</span></span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line">mk = imageio.imread(<span class="string">"xiaolan.png"</span>)</span><br><span class="line">w = wordcloud.WordCloud(mask=mk)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建并配置词云对象w，注意要加scale参数，提高清晰度</span></span><br><span class="line">w = wordcloud.WordCloud(width=<span class="number">1000</span>,</span><br><span class="line">                        height=<span class="number">700</span>,</span><br><span class="line">                        background_color=<span class="string">'white'</span>,</span><br><span class="line">                        font_path=<span class="string">'simkai.ttf'</span>,</span><br><span class="line">                        mask=mk,</span><br><span class="line">                        scale=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对来自外部文件的文本进行中文分词，得到string  ，有可能会遇到编码问题，这个可以根据报错来</span></span><br><span class="line">f = open(<span class="string">'知乎甜话.txt'</span>)</span><br><span class="line">txt = f.read()</span><br><span class="line">txtlist = jieba.lcut(txt)</span><br><span class="line">string = <span class="string">" "</span>.join(txtlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将string变量传入w的generate()方法，给词云输入文字</span></span><br><span class="line">w.generate(string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将词云图片导出到当前文件夹</span></span><br><span class="line">w.to_file(<span class="string">'chao1.png'</span>)</span><br></pre></td></tr></table></figure>

<p>上传不了图片！</p>
<p>TODO：颜色 &amp; 字体</p>
</div></div><a class="button-hover more" href="/2020/02/13/Python词云/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/10/惩罚线性回归模型/">惩罚线性回归模型</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-02-10</time></div><div class="post-content"><div class="main-content content"><h1 id="惩罚线性回归"><a href="#惩罚线性回归" class="headerlink" title="惩罚线性回归"></a>惩罚线性回归</h1><p>产生背景：<br>线性回归可以理解为“拟合”，一般采用普通最小二乘方法OLS（ordinary least square），但是对于拟合问题存在一个过拟合的问题，为了避免这种现象，提出了惩罚线性回归模型，要求模型对于训练数据具有较好的<strong>学习能力</strong>，同时也要<strong>平衡系数参数的惯性能量</strong></p>
<h2 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h2><p>通过设置不同大小的alpha，获得最终的预测结果以及ROC曲线，通过比较ROC曲线下的面积（AUC）获得optimal alpha。AUC越大越好。另外一般就取alpha=0.85吧。</p>
<h2 id="求解惩罚线性回归问题"><a href="#求解惩罚线性回归问题" class="headerlink" title="求解惩罚线性回归问题"></a>求解惩罚线性回归问题</h2><p>最小角度回归LARS算法<br>10折交叉验证就是将输入数据且分为10份几乎均等的数据（10折表示10%用于测试，5折表示20%用于测试）</p>
<p>我们采用自己实现的LARS算法，实现求解惩罚线性回归问题。而在python里面有直接的安装包实现lasso（套索）回归型函数。</p>
</div></div><a class="button-hover more" href="/2020/02/10/惩罚线性回归模型/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/07/R语言（DrImpute &amp; VIPER）/">R语言（DrImpute &amp; VIPER）</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-02-15</time></div><div class="post-content"><div class="main-content content"><h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><h3 id="技术型的"><a href="#技术型的" class="headerlink" title="技术型的"></a>技术型的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zero.rate &lt;- apply(xx, 1, function(x)&#123;length(x[x == 0])&#125;)/n</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zero.matrix &lt;- apply(zero.matrix, 2, as.numeric)</span><br></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply(,,)"></a>apply(,,)</h4><p>第一个参数是指要参与计算的<strong>矩阵</strong><br>第二个参数是指按行计算还是按列计算，1——表示按<strong>行</strong>计算，2——按<strong>列</strong>计算<br>第三个参数是指具体的运算参数。 (sum ,可以自定义，此处是自定义)</p>
<p>第三个参数为as.numeric不知道有什么用？<br>as.numeric 转化成整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag &lt;-  zero.rate &lt;= percentage.cutoff</span><br></pre></td></tr></table></figure>

<h4 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h4><p>&lt;=<br>检查第一向量的每个元素是否小于或等于第二向量的相应元素。</p>
<p>%%<br>两个向量求余<br>％/％<br>两个向量相除求商<br>^<br>将第二向量作为第一向量的指数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D &lt;- D + Y[i, ]%*%t(Y[i, ])</span><br></pre></td></tr></table></figure>

<p>%*%<br>表示通常意义下的两个矩阵的乘积</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(percentage.cutoff &gt;= 0.25)</span><br><span class="line">    warnings(&apos;The prediction model may not be accurate since there are not enough genes that have low zero rates.&apos;)</span><br></pre></td></tr></table></figure>

<h4 id="warnings-‘’"><a href="#warnings-‘’" class="headerlink" title="warnings(‘’)"></a>warnings(‘’)</h4><p>友好提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx &lt;- as.matrix(xx)</span><br></pre></td></tr></table></figure>

<h4 id="as-matrix"><a href="#as-matrix" class="headerlink" title="as.matrix()"></a>as.matrix()</h4><p>将其参数转换为矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- logxx[round(runif(num)*p), ]</span><br></pre></td></tr></table></figure>

<h4 id="runif"><a href="#runif" class="headerlink" title="runif()"></a>runif()</h4><p>runif()函数用于生成从0到1区间范围内的服从正态分布的随机数，每次生成的值都不一样；set.seed()用于生成随机数的种子元素，两个函数配合起来发挥作用。</p>
<h4 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h4><p>round函数用于舍入到最接近的整数。round(2.1) = 2;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selection &lt;- match.arg(selection)</span><br></pre></td></tr></table></figure>

<h4 id="match-arg"><a href="#match-arg" class="headerlink" title="match.arg()"></a>match.arg()</h4><p>match.arg可以用来做类型匹配</p>
<h4 id><a href="#" class="headerlink" title="$"></a>$</h4><p>当一个函数里需要返回多个值（比如有变量，有向量，有矩阵）时，我们要用list,而不是return，这时如果想提取某个变量的结果，就需要用到$，默认情况下，对于 ‘list’, ‘environment’这两种对象，$ 可以提取（extract）出里面的元素。<br>x$y  等价于 x[[“y”, exact = FALSE]]，用于获取dataframe或者list里面的某个变量，比如mtcars$cyl 和 diamonds$carat。不同之处在于 $ 可以部分匹配变量名，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- list(abc = 1)</span><br><span class="line">x$a</span><br><span class="line">#&gt; [1] 1</span><br><span class="line">x[[&quot;a&quot;]]</span><br><span class="line">#&gt; NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RcppExports.R</span><br></pre></td></tr></table></figure>

<h4 id="RcppExports-R"><a href="#RcppExports-R" class="headerlink" title="RcppExports.R"></a>RcppExports.R</h4><p>其不可删除，删除了也会自动再出现。其调用了.cpp的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">suppressMessages(require(quadprog))</span><br></pre></td></tr></table></figure>

<h4 id="suppressMessages"><a href="#suppressMessages" class="headerlink" title="suppressMessages()"></a>suppressMessages()</h4><p>使用suppressMessages运行的时候不显示提示信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d &lt;- rep(0, k)</span><br></pre></td></tr></table></figure>

<h4 id="rep-x-time-length-each"><a href="#rep-x-time-length-each" class="headerlink" title="rep(x, time = , length = , each = ,)"></a>rep(x, time = , length = , each = ,)</h4><p>x：代表的是你要进行复制的对象，可以是一个向量或者是一个因子。<br>times：代表的是复制的次数，只能为正数。负数以及NA值都会为错误值。复制是指的是对整个向量进行复制。<br>each：代表的是对向量中的每个元素进行复制的次数。<br>length.out：代表的是最终输出向量的长度。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line">rep(1:4, 2)  #对向量（1,2,3,4）复制两次</span><br><span class="line">[1] 1 2 3 4 1 2 3 4</span><br><span class="line">rep(1:4, each = 2)   #对向量（1,2,3,4）中的每个元素复制两次</span><br><span class="line">[1] 1 1 2 2 3 3 4 4</span><br><span class="line">rep(1:4, each = 2, length.out = 4)  #最后输出向量的长度为4</span><br><span class="line">[1] 1 1 2 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A &lt;- rbind(diag(k), - diag(k))</span><br></pre></td></tr></table></figure>

<h4 id="rbind-a-b"><a href="#rbind-a-b" class="headerlink" title="rbind(a,b)"></a>rbind(a,b)</h4><p>cbind： 根据列进行合并，即叠加所有列，m列的矩阵与n列的矩阵cbind()最后变成m+n列，合并前提：cbind(a, c)中矩阵a、c的行数必需相符</p>
<p>rbind： 根据行进行合并，就是行的叠加，m行的矩阵与n行的矩阵rbind()最后变成m+n行，合并前提：rbind(a, c)中矩阵a、c的列数必需相符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line">&gt; a &lt;- matrix(1:12, 3, 4)</span><br><span class="line">&gt; print(a)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    4    7   10</span><br><span class="line">[2,]    2    5    8   11</span><br><span class="line">[3,]    3    6    9   12</span><br><span class="line">&gt; </span><br><span class="line">&gt; b &lt;- matrix(-1:-12, 3, 4)</span><br><span class="line">&gt; print(b)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]   -1   -4   -7  -10</span><br><span class="line">[2,]   -2   -5   -8  -11</span><br><span class="line">[3,]   -3   -6   -9  -12</span><br><span class="line">&gt; </span><br><span class="line">&gt; x=cbind(a,b)</span><br><span class="line">&gt; print(x)</span><br><span class="line">     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]</span><br><span class="line">[1,]    1    4    7   10   -1   -4   -7  -10</span><br><span class="line">[2,]    2    5    8   11   -2   -5   -8  -11</span><br><span class="line">[3,]    3    6    9   12   -3   -6   -9  -12</span><br><span class="line">&gt; </span><br><span class="line">&gt; y=rbind(a,b)</span><br><span class="line">&gt; print(y)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    4    7   10</span><br><span class="line">[2,]    2    5    8   11</span><br><span class="line">[3,]    3    6    9   12</span><br><span class="line">[4,]   -1   -4   -7  -10</span><br><span class="line">[5,]   -2   -5   -8  -11</span><br><span class="line">[6,]   -3   -6   -9  -12</span><br></pre></td></tr></table></figure>

<h4 id="diag"><a href="#diag" class="headerlink" title="diag()"></a>diag()</h4><p>diag()提取或替换一个矩阵的对角线,或构造一个对角矩阵。<br>语法：<br>diag(x = 1, nrow, ncol)<br>diag(x) &lt;- value<br>解析：<br>x：一个矩阵,向量或一维数组,或不填写。<br>nrow, ncol：可选 行列。<br>value ：对角线的值，可以是一个值或一个向量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line">&gt; x &lt;- matrix(1:16,nrow=4,ncol=4)</span><br><span class="line">&gt; x</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    5    9   13</span><br><span class="line">[2,]    2    6   10   14</span><br><span class="line">[3,]    3    7   11   15</span><br><span class="line">[4,]    4    8   12   16</span><br><span class="line">&gt; diag(x)</span><br><span class="line">[1]  1  6 11 16</span><br><span class="line">#展示x的对角线数据</span><br><span class="line"></span><br><span class="line">&gt; diag(diag(x))</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    0    0    0</span><br><span class="line">[2,]    0    6    0    0</span><br><span class="line">[3,]    0    0   11    0</span><br><span class="line">[4,]    0    0    0   16</span><br><span class="line">#由x的对角线数据生成对角矩阵</span><br><span class="line"></span><br><span class="line">&gt; diag(4)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    1    0    0    0</span><br><span class="line">[2,]    0    1    0    0</span><br><span class="line">[3,]    0    0    1    0</span><br><span class="line">[4,]    0    0    0    1</span><br><span class="line">#对角线为4个元素每个元素默认为1的对角矩阵</span><br><span class="line"></span><br><span class="line">&gt; diag(10,3,4)</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]   10    0    0    0</span><br><span class="line">[2,]    0   10    0    0</span><br><span class="line">[3,]    0    0   10    0</span><br><span class="line">#对角线数据位10,三行四列的矩阵</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; a&lt;-diag(4)+1</span><br><span class="line">&gt; a</span><br><span class="line">     [,1] [,2] [,3] [,4]</span><br><span class="line">[1,]    2    1    1    1</span><br><span class="line">[2,]    1    2    1    1</span><br><span class="line">[3,]    1    1    2    1</span><br><span class="line">[4,]    1    1    1    2</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Visualiztion</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">palette.gr.marray &lt;- colorRampPalette(c(&quot;white&quot;, &quot;red&quot;))(4)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="colorRampPalette-c-“white”-“red”-4"><a href="#colorRampPalette-c-“white”-“red”-4" class="headerlink" title="colorRampPalette(c(“white”, “red”))(4)"></a>colorRampPalette(c(“white”, “red”))(4)</h4><p>函数的参数c(“white”, “red”) 指的是颜色从红色渐变到红色，4 代表创建长度为4的颜色梯度<br>有了颜色梯度之后，我们就可以方便的把数值映射到颜色梯度上<br>基本的思想是，将数值排序，然后得到每个数值在排序好的序列中的顺序，其实就是rank 函数的返回值，然后利用该顺序去获取颜色</p>
<p>##　DrImpute</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cor()</span><br></pre></td></tr></table></figure>

<p>R内置函数cor()可以用来计算相关系数：cor(x, method = c(“pearson”, “kendall”, “spearman”))，如果数据有缺失值，用cor(x, method = “pearson”, use = “complete.obs”)。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expand.grid()</span><br></pre></td></tr></table></figure>

<p>构造一个数据框，将各参数的各水平完全搭配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ikwak2/DrImpute</span><br></pre></td></tr></table></figure>

<p>这个好像是经过改进的</p>
<p>主成分分析 (PCA, principal component analysis)是一种数学降维方法, 利用正交变换 (orthogonal transformation)把一系列可能线性相关的变量转换为一组线性不相关的新变量，也称为主成分，从而利用新变量在更小的维度下展示数据的特征。</p>
<p>主成分是原有变量的线性组合，其数目不多于原始变量。组合之后，相当于我们获得了一批新的观测数据，这些数据的含义不同于原有数据，但包含了之前数据的大部分特征，并且有着较低的维度，便于进一步的分析。</p>
<p>在空间上，PCA可以理解为把原始数据投射到一个新的坐标系统，第一主成分为第一坐标轴，它的含义代表了原始数据中多个变量经过某种变换得到的新变量的变化区间；第二成分为第二坐标轴，代表了原始数据中多个变量经过某种变换得到的第二个新变量的变化区间。这样我们把利用原始数据解释样品的差异转变为利用新变量解释样品的差异。</p>
</div></div><a class="button-hover more" href="/2020/02/07/R语言（DrImpute &amp; VIPER）/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/06/账号中心/">账号中心</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-02-14</time></div><div class="post-content"><div class="main-content content"><ul>
<li>DAO层：<blockquote>
<p>DAO层叫<strong>数据访问层</strong>，全称为<strong>data access object</strong>，属于一种比较底层，比较基础的操作，具体到对于某个<em>表的增删改查</em>，建议DAO只做原子操作，增删改查。<br>通常我们在DAO层里面写<strong>接口</strong>，里面有与数据打交道的方法。SQL语句通常写在mapper文件里面的。</p>
</blockquote>
</li>
</ul>
<ul>
<li>Controler层：<blockquote>
<p>Controler负责请求转发，接收页面过来的参数，传给<strong>Service</strong>处理，接到返回值，再传给页面。</p>
</blockquote>
</li>
</ul>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法。通俗来说，被Controller标记的类就是一个控制器，这个类中的方法，就是相应的动作。</p>
<p>Alt+Insert键可以加入get和set方法</p>
</div></div><a class="button-hover more" href="/2020/02/06/账号中心/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/02/05/yc的聊天器（Ubuntu）/">yc的聊天器（NIO）</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 本机client编号</span><br><span class="line"> */</span><br><span class="line">private int thisClientNumber = -1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 客户端多路选择器</span><br><span class="line"> */</span><br><span class="line">private Selector selector;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 客户端和服务端连接channel</span><br><span class="line"> */</span><br><span class="line">private SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 聊天工具类</span><br><span class="line"> */</span><br><span class="line">private ChartUtil chartUtil;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Client client = new Client();</span><br><span class="line">    client.initial();</span><br><span class="line">    client.inputThread();</span><br><span class="line">    client.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br></pre></td></tr></table></figure>

<p>从通道读取：创建一个缓冲区，然后请求通道读取数据。<br>通道写入：创建一个缓冲区，填充数据，并要求通道写入数据。</p>
<p><strong>核心部件</strong></p>
<ul>
<li>Channel</li>
<li>Buffer</li>
<li><em>Selector</em></li>
</ul>
<p><strong>通道列表</strong></p>
<ul>
<li>DatagramChannel</li>
<li><em>SocketChannel</em></li>
<li>FileChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p><strong>缓冲列表</strong></p>
<ul>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li><em>ByteBuffer</em></li>
<li>ShortBuffer</li>
<li>FloatBuffer</li>
</ul>
<p><strong>选择器</strong><br>Java NIO提供了“选择器”的概念。这是一个可以用于监视多个通道的对象，如数据到达，连接打开等。因此，单线程可以监视多个通道中的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SneakyThrows</span><br><span class="line">private void initial() &#123;</span><br><span class="line">    selector = Selector.open();</span><br><span class="line">    socketChannel = SocketChannel.open();</span><br><span class="line">    socketChannel.configureBlocking(false);</span><br><span class="line">    chartUtil = new ChartUtil();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span>接着看完</span></span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2020/02/05/yc的聊天器（Ubuntu）/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Rr-shan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>