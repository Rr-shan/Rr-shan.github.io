<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Rr-shan,undefined"><meta name="copyright" content="Rr-shan"><title>【Sanzzi】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Rr-shan</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Rr-shan" target="_blank">GitHub<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="mailto:1224559633@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color6"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="archives"><span class="pull-top">日志</span><span class="pull-bottom">42</span></a><a class="author-info-articles-tags article-meta" href="tags"><span class="pull-top">标签</span><span class="pull-bottom">12</span></a><a class="author-info-articles-categories article-meta" href="categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="https://chao-yin-github.github.io/" target="_blank">yccccc~~~~~~~~</a><a class="friend-link-text" href="https://sanzzi.cn" target="_blank">Mywebsite</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Sanzzi</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="2020/04/08/没能成功去泰迪杯的原因/">没能成功去泰迪杯的原因</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-08</time></div><div class="post-content"><div class="main-content content">已被加密啦</div></div><a class="button-hover more" href="2020/04/08/没能成功去泰迪杯的原因/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/04/05/生涯规划课之如何写一份优秀的简历/">生涯规划课之如何写一份优秀的简历</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-05</time></div><div class="post-content"><div class="main-content content">已被加密啦</div></div><a class="button-hover more" href="2020/04/05/生涯规划课之如何写一份优秀的简历/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/04/05/解析二级域名后看是否生效/">解析二级域名后看是否生效</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-05</time></div><div class="post-content"><div class="main-content content"><h5 id="阿里云的二级域名解析："><a href="#阿里云的二级域名解析：" class="headerlink" title="阿里云的二级域名解析："></a>阿里云的二级域名解析：</h5><p><strong>解析线路：</strong>选择 默认 （默认为必选项，如未设置会导致部分用户无法访问 )。<br><strong>TTL：</strong>为缓存时间，数值越小，<strong>修改记录各地生效时间越快</strong>，默认为10分钟。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ping</span> yc.sanzzi.cn</span><br></pre></td></tr></table></figure>

<p>如果生效是以下这样的</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正在 <span class="built_in">Ping</span> yc.sanzzi.cn [<span class="number">123</span>.<span class="number">57</span>.<span class="number">242</span>.<span class="number">220</span>] 具有 <span class="number">32</span> 字节的数据:</span><br><span class="line">来自 <span class="number">123</span>.<span class="number">57</span>.<span class="number">242</span>.<span class="number">220</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">43</span>ms TTL=<span class="number">49</span></span><br><span class="line">来自 <span class="number">123</span>.<span class="number">57</span>.<span class="number">242</span>.<span class="number">220</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">43</span>ms TTL=<span class="number">49</span></span><br><span class="line">来自 <span class="number">123</span>.<span class="number">57</span>.<span class="number">242</span>.<span class="number">220</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">308</span>ms TTL=<span class="number">49</span></span><br><span class="line">来自 <span class="number">123</span>.<span class="number">57</span>.<span class="number">242</span>.<span class="number">220</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">170</span>ms TTL=<span class="number">49</span></span><br><span class="line"></span><br><span class="line"><span class="number">123</span>.<span class="number">57</span>.<span class="number">242</span>.<span class="number">220</span> 的 <span class="built_in">Ping</span> 统计信息:</span><br><span class="line">    数据包: 已发送 = <span class="number">4</span>，已接收 = <span class="number">4</span>，丢失 = <span class="number">0</span> (<span class="number">0</span>% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = <span class="number">43</span>ms，最长 = <span class="number">308</span>ms，平均 = <span class="number">141</span>ms</span><br></pre></td></tr></table></figure>

<p>失败是</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Ping</span> 请求找不到主机 sanzi.sanzzi.cn。请检查该名称，然后重试。</span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="2020/04/05/解析二级域名后看是否生效/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/04/01/srf之论文阅读Dr.VAE/">srf之论文阅读Dr.VAE</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-06</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="categories/DeepLearning/">DeepLearning</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="tags/srf/">srf</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Dr-VAE-improving-drug-response-prediction-via-modeling-of-drug-perturbation-effects"><a href="#Dr-VAE-improving-drug-response-prediction-via-modeling-of-drug-perturbation-effects" class="headerlink" title="Dr.VAE: improving drug response prediction via modeling of drug perturbation effects"></a>Dr.VAE: improving drug response prediction via modeling of drug perturbation effects</h1><hr>
<h2 id="1-为什么要讲这个"><a href="#1-为什么要讲这个" class="headerlink" title="1. 为什么要讲这个?"></a>1. 为什么要讲这个?</h2><p><strong>Motivation:</strong><br>将<strong>生物系统的现有知识</strong>融入到这些方法中是<strong>提高预测性能</strong>的一个很有前途的途径。<br><strong>药物诱导转录组扰动效应的高通量细胞系分析</strong>(High-throughput cell line assays of drug-induced transcriptomic perturbation effects)是一项尚未完全纳入药物反应预测模型的先验知识。</p>
<h2 id="2-提出了什么方法"><a href="#2-提出了什么方法" class="headerlink" title="2. 提出了什么方法 ?"></a>2. 提出了什么方法 ?</h2><ul>
<li>药物反应变异自动编码器（<strong>Dr.VAE</strong>）（Drug Response Variational Autoencoder），这是一种<strong>深度生成模型</strong>，可以根据<strong>转录组扰动特征预测药物反应</strong>。Dr.VAE是一个概率图形模型，其中每个条件分布都由一个<strong>深度神经网络</strong>来计算。该模型共同学习药物反应预测因子和基因表达的低维潜在表示中的药物扰动效应生成模型。</li>
<li>结果：对于26种经过美国食品药品监督管理局（FDA）批准的测试药物，<strong>Dr.VAE的性能达到或优于标准分类方法</strong>。<blockquote>
<p>药物诱导转录组扰动效应，为什么谷歌不到相关信息！！？？</p>
</blockquote>
</li>
</ul>
<h2 id="3-传统方法有什么问题-（对比）"><a href="#3-传统方法有什么问题-（对比）" class="headerlink" title="3. 传统方法有什么问题?（对比）"></a>3. 传统方法有什么问题?（对比）</h2><p>在论文Introduction部分，并没有直接说之前的方法存在什么问题，而是罗列已有的成果。(略)<br>补充说一下Dr.VAE这个方法的具体启发：<br>Niepel 等人（2017）从最初的CMap开始研究了六种乳腺癌细胞系的转录组扰动，并结合表型药物反应测量来确定具有相似表型药物反应的细胞系在药物诱导的基因表达扰动中是否也具有相同的模式。<br>他们的分析得出结论，<strong>某些药物（细胞周期激酶抑制剂）就是这种情况，但对于其他药物，分子反应是细胞类型特异性的，对于某些药物-细胞系组合，显着的转录扰动对细胞没有影响</strong>。这些结果促使我们开发出一种统一的方法，该方法可以确定更复杂的分子扰动和表型反应关联，这些关联对于细胞系亚群可能是唯一的。</p>
<p>有关使用VAE的进展</p>
<ul>
<li>Way and Greene（2018）已证明VAE可以提取出癌症转录组谱的生物学意义。</li>
<li>Dincer 等（2018）在名为DeepProfile的药物反应预测方法中结合了<strong>预训练的VAE</strong>和<strong>单独训练的线性模型</strong>。</li>
</ul>
<h2 id="4-原理"><a href="#4-原理" class="headerlink" title="4. 原理"></a>4. 原理</h2><h3 id="简单了解一下VAE"><a href="#简单了解一下VAE" class="headerlink" title="简单了解一下VAE"></a>简单了解一下VAE</h3><h4 id="模型图："><a href="#模型图：" class="headerlink" title="模型图："></a>模型图：</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDIwMDQvMDYvMTU4NjE3NTMyN18zODU5NzIucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>下面这幅图可能容易理解一些<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9rZXh1ZS5mbS91c3IvdXBsb2Fkcy8yMDE4LzAzLzQxNjg4NzY2NjIucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="效果（目的）："><a href="#效果（目的）：" class="headerlink" title="效果（目的）："></a>效果（目的）：</h4><p><img src="https://img-blog.csdnimg.cn/20190226215534296.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019022621561853.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="到这里，开始介绍Dr-VAE"><a href="#到这里，开始介绍Dr-VAE" class="headerlink" title="到这里，开始介绍Dr.VAE"></a>到这里，开始介绍Dr.VAE</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDIwMDQvMDQvMTU4NTk5MzY3OF82MzY0NzEucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>x1是没有经过药物作用的，也就是没有转录组扰动效应</li>
<li>x2是经过药物作用后的。</li>
<li>z1,z2是隐参数，对于x1,x2</li>
<li>y是显示预测相关性的</li>
<li>z3 class-independent，独立的，正态分布<h4 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h4><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDIwMDQvMDYvMTU4NjE2NjI5NV85OTcxNTIucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDIwMDQvMDQvMTU4NTk5MzY4N181MzM3Ny5wbmc?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<p>图a：Dr.VARE<br>图b:<br>图c:我们需要能够从观察到的形式对<strong>隐藏变量</strong>（z1,z2）进行有效推断变量，我们转向随机变分推断并引入真实<strong>后验的近似值q</strong>。<br>图d:Dr.VARE一点的例子<br>图f： PertVAE：无监督模型，用来研究药物效应模型对学习的潜在基因表达表示的贡献</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDIwMDQvMDYvMTU4NjE3MTM2NV83MjY5NTYucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>不是很明白为什么这样子会好一些？？？</p>
<hr>
<h3 id="encoder-amp-decoder层次的设计"><a href="#encoder-amp-decoder层次的设计" class="headerlink" title="encoder&amp;decoder层次的设计"></a>encoder&amp;decoder层次的设计</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDIwMDQvMDYvMTU4NjE3NTI0MV8yOTQ2MTEucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="整个参数设计的代码体现"><a href="#整个参数设计的代码体现" class="headerlink" title="整个参数设计的代码体现"></a>整个参数设计的<em>代码体现</em></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">model = DrVAE(dim_x=dim_x, dim_s=dim_s, dim_y=dim_y, dim_z1=args.dim_z1, dim_z3=args.dim_z3,</span><br><span class="line">              dim_h_en_z1=args.enc_z1, dim_h_en_z3=args.enc_z3, dim_h_en_z2Fz1=args.enc_z2Fz1,</span><br><span class="line">              dim_h_de_z1=args.dec_z1, dim_h_de_x=args.dec_x, type_rec=<span class="string">'diag_gaussian'</span>,</span><br><span class="line">              dim_h_clf=args.class_y, type_y=args.type_y, prior_y=prior_y,</span><br><span class="line">              optim_alg=<span class="string">'adam'</span>, batch_size=args.batch_size, epochs=<span class="number">300</span>,</span><br><span class="line">              nonlinearity=<span class="string">'elu'</span>, L=args.L,</span><br><span class="line">              weight_decay=<span class="number">0.05</span>, dropout_rate=<span class="number">0.</span>, input_x_dropout=args.x_dropout, add_noise_var=args.noise_var,</span><br><span class="line">              learning_rate=<span class="number">0.0005</span>, yloss_rate=args.yloss_rate, clf_z1z2=<span class="literal">True</span>, clf_1sig=args.clf_1sig,</span><br><span class="line">              anneal_yloss_offset=args.anneal_yloss_offset,</span><br><span class="line">              kl_qz2pz2_rate=<span class="number">1.</span>, pertloss_rate=<span class="number">0.05</span>, anneal_perturb_rate_itermax=<span class="number">1</span>, anneal_perturb_rate_offset=<span class="number">0</span>,</span><br><span class="line">              use_s=args.useS, use_MMD=args.useMMD, kernel_MMD=<span class="string">'rbf_fourier'</span>, mmd_rate=args.mmd_rate,  <span class="comment">## &lt;= settings for "fairness" (like VFAE)</span></span><br><span class="line">              random_seed=args.rseed, log_txt=<span class="literal">None</span>  <span class="comment">#'DrVAE_SD_&#123;&#125;_&#123;&#125;.txt'.format(args.modelid, selected_drug)</span></span><br><span class="line">              )</span><br></pre></td></tr></table></figure>

<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算KL散度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fprop</span><span class="params">(self, z1, qz1, y)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有loss</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_compute_losses</span><span class="params">(self, x1, x2, s, y, L)</span>:</span></span><br><span class="line">   <span class="string">"""     </span></span><br><span class="line"><span class="string">   计算模型的所有损失。 对于未标记的数据，将y边缘化。</span></span><br><span class="line"><span class="string">   Compute all losses of the model. For unlabeled data marginalize y.</span></span><br><span class="line"><span class="string">   RECL - reconstruction loss E_&#123;q(z1|x1)&#125;[ p(x1|z1) ] </span></span><br><span class="line"><span class="string">   KLD  - kl-divergences of all the other matching q and p distributions所有其他匹配q和p分布的kl-散度</span></span><br><span class="line"><span class="string">   PERT - perturbation prediction loss E_&#123;p(z2|z1)q(z1|x1)&#125;[ p(x2|z2) ]</span></span><br><span class="line"><span class="string">   YL   - prediction loss on y (for labeled data)</span></span><br><span class="line"><span class="string">   MMD  - maximum mean discrepancy of z1 embedding w.r.t. grouping s</span></span><br><span class="line"><span class="string">   """</span></span><br></pre></td></tr></table></figure>

<h2 id="5-数据集是怎么划分的"><a href="#5-数据集是怎么划分的" class="headerlink" title="5. 数据集是怎么划分的?"></a>5. 数据集是怎么划分的?</h2><blockquote>
<p><strong>Training data sets</strong>：<strong>CTRPv2</strong>( Cancer Therapeutic Response Portal)  &amp;  <strong>CMap</strong> (CMap-L1000v1)<br><strong>Input data types</strong>：<strong>mRNA</strong> EXP (before &amp; after treatment)</p>
</blockquote>
<h3 id="两个数据集的基本介绍："><a href="#两个数据集的基本介绍：" class="headerlink" title="两个数据集的基本介绍："></a>两个数据集的基本介绍：</h3><p><strong>CTRPv2</strong>：为860个细胞系和481个药物化合物的组合<strong>提供了不同药物浓度下细胞系的相对生存能力</strong>。细胞系对<strong>药物治疗的敏感性</strong>通过<strong>剂量-反应曲线AAC</strong>上方的面积来量化，我们进一步采用瀑布法对连续的AAC进行二值化（Barretina等人，2012；Haibe-Kains等人，2013），<strong>将灵敏度预测任务转化为离散的分类任务。</strong>  <del>体现在哪里？</del><br><strong>CMap</strong>：筛选了19 811种药物化合物对多达77个细胞系中<strong>L1000个标志性基因表达</strong>的干扰效应。<br>在CMap中的实验并<strong>不能测量药物治疗的敏感性</strong>，但是一些细胞系也在CTRPv2中进行了独立的测试。我们<strong>交叉</strong>引用这些细胞系(取交集)，并将相应的标签分配给它们的扰动测量。</p>
<h3 id="实验数据选择标准："><a href="#实验数据选择标准：" class="headerlink" title="实验数据选择标准："></a>实验数据选择标准：</h3><ol>
<li>从CMap数据集，选择了在<strong>最常见浓度水平下对每种药物进行6小时的微扰实验</strong>。(如果细胞系没有在选定的浓度下进行检测，我们使用最接近的检测浓度。接下来，我们将对照组（DMSO载体）实验与药物扰动实验通过批次ID和微珠ID进行匹配，以最小化病例和对照组之间的批次效应。<del>？</del> 此外，我们通过相关性（&gt;0.75 Pearson q）过滤所选的病例对照对，以过滤出可能标记错误的实验或异常值。)</li>
<li>CTRPv2和CMap-L1000v1数据集共有<strong>973</strong>个<strong>共同基因</strong>。将<strong>每个基因的表达值标准化为零均值和单位方差</strong>。为了进一步的均匀化，包括去除批效应和两个合并数据之间的差异，我们还从集合数据集中去除了第一个主成分（解释了12.8%的变化）。</li>
</ol>
<p>基于以上两个标准，我们选择了<strong>26</strong>种在CTRPv2和CMap-L1000v1数据集中测试的<strong>药物</strong>：</p>
<ul>
<li>对于每种选择的药物，至少有<strong>8个不同的细胞系在CMap干扰实验中测试。</strong></li>
<li>CTRPv2中至少有20%的筛选细胞系在剂量-反应AAC二值化后<strong>对药物敏感</strong>。</li>
</ul>
<p>（忽略后面的可以看一下第一列的药物）<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDIwMDQvMDYvMTU4NjE1ODgwNV85NzAxNjAucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br><em>代码体现</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## drug selection  </span></span><br><span class="line">drug_list_26 = [<span class="string">'omacetaxine mepesuccinate'</span>, <span class="string">'bortezomib'</span>, <span class="string">'vorinostat'</span>, <span class="string">'paclitaxel'</span>, <span class="string">'docetaxel'</span>, <span class="string">'topotecan'</span>,</span><br><span class="line">                <span class="string">'niclosamide'</span>, <span class="string">'valdecoxib'</span>,<span class="string">'teniposide'</span>, <span class="string">'vincristine'</span>, <span class="string">'prochlorperazine'</span>, <span class="string">'mitomycin'</span>, <span class="string">'lovastatin'</span>,</span><br><span class="line">                <span class="string">'gemcitabine'</span>, <span class="string">'dasatinib'</span>, <span class="string">'fluvastatin'</span>, <span class="string">'clofarabine'</span>, <span class="string">'sirolimus'</span>, <span class="string">'etoposide'</span>, <span class="string">'sitagliptin'</span>,</span><br><span class="line">                <span class="string">'decitabine'</span>, <span class="string">'PLX-4032'</span>, <span class="string">'fulvestrant'</span>, <span class="string">'bosutinib'</span>, <span class="string">'trifluoperazine'</span>, <span class="string">'ciclosporin'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="7-交叉验证怎么做"><a href="#7-交叉验证怎么做" class="headerlink" title="7. 交叉验证怎么做?"></a>7. 交叉验证怎么做?</h2><p>通过执行20次重复的<strong>5折交叉验证</strong>，我们生成了100个训练验证测试数据。<br><em>代码体现</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSplitsByGroupKFold</span><span class="params">(groups, fold, n_splits, shuffle, random_state)</span>:</span></span><br><span class="line">    <span class="string">'''the same group will not appear in two different folds'''</span></span><br></pre></td></tr></table></figure>

<h2 id="8-Discussion："><a href="#8-Discussion：" class="headerlink" title="8. Discussion："></a>8. Discussion：</h2><p>典型的判别前馈神经网络在药物反应预测中效果不佳，很可能是由于数据限制（特征数量与样本数量）所致。 我们表明，<strong>药物反应和扰动效应的联合生成模型</strong>在很大程度上缓解了这种情况，<strong>可能起到了有效的正则化和鲁棒的特征提取的作用</strong>，而不会产生过拟合的情况。</p>
<h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h3><ol>
<li>只考虑基因表达方式，<strong>没有额外整合</strong>甲基化、拷贝数变化、相互作用状态的<strong>多组预测因子。</strong></li>
<li>我们在每种药物最常见的浓度水平下，对治疗6小时后的CMap-L1000v1扰动进行建模。有人认为，<strong>6小时太短，许多反馈调节机制无法体现自己，因此这些实验本身并不能提供完整的转录反应图片</strong>。值得注意的是，药物细胞系活力测定通常在较长的治疗时间（如72小时）内完成。因此，我们也用24小时的微扰实验来训练我们的VAE博士，然而，<strong>由于这样的实验数量有限</strong>，这并没有提高我们的预测性能。</li>
<li>Dr.VAE所组成的每一个条件分布都是由一个神经网络参数化的。调整超参数以匹配数据复杂性的能力使Dr.VAE成为一个非常灵活的模型。<strong>由于我们选择了简单性，我们的神经网络大多有一个隐藏层，而分类后验函数和扰动函数是线性的。</strong> 然而，到目前为止，我们试图通过更复杂的分布使用更深的网络或使用规范化流来近似后验的尝试，<strong>并没有显著地提高性能来证明增加的复杂性。</strong></li>
</ol>
<hr>
<h2 id="补充知识："><a href="#补充知识：" class="headerlink" title="补充知识："></a>补充知识：</h2><h3 id="ablation-study消融实验"><a href="#ablation-study消融实验" class="headerlink" title="ablation study消融实验:"></a>ablation study消融实验:</h3><p>论证是什么起了作用，类似于中学学的控制变量。模型简化测试。看看取消掉一些模块后性能有没有影响。<br>本实验通过 Dr.VAE w / I来验证<br><em>代码体现</em></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_w_pert_identity</span><span class="params">(self, x1, x2, s=[])</span>:</span></span><br></pre></td></tr></table></figure>

<h3 id="Result部分"><a href="#Result部分" class="headerlink" title="Result部分"></a>Result部分</h3><p><em>代码体现</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classif_baseline_perf</span><span class="params">(xtrain, ytrain, xtest, ytest, svmkernel=<span class="string">'rbf'</span>, rseed=None)</span>:</span></span><br><span class="line">    <span class="string">'''这个包括了和 Random Forest、LogisticRegression、SVM、SVM w/ linear kernel的对比'''</span></span><br><span class="line">    data = [xtrain, ytrain, xtest, ytest]</span><br><span class="line">    perf = OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## Random Forest</span></span><br><span class="line">    cl = sklearn.ensemble.RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=rseed)</span><br><span class="line">    rf_perf = measure_cl_perf(cl, <span class="string">'RF100'</span>, *data)</span><br><span class="line">    perf = concat_dicts(perf, rf_perf)</span><br><span class="line"></span><br><span class="line">	<span class="comment">## LogisticRegression</span></span><br><span class="line">    cl = sklearn.linear_model.LogisticRegressionCV(penalty=<span class="string">'l2'</span>, random_state=rseed)</span><br><span class="line">    lr_perf = measure_cl_perf(cl, <span class="string">'Ridge'</span>, *data)</span><br><span class="line">    perf = concat_dicts(perf, lr_perf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## SVM </span></span><br><span class="line">    cl = sklearn.svm.SVC(kernel=svmkernel, probability=<span class="literal">True</span>, random_state=rseed)</span><br><span class="line">    svm_perf = measure_cl_perf(cl, <span class="string">'SVM'</span> + svmkernel[:<span class="number">3</span>], *data)</span><br><span class="line">    perf = concat_dicts(perf, svm_perf)</span><br><span class="line">    <span class="comment"># SVM w/ linear kernel</span></span><br><span class="line">    cl = sklearn.svm.SVC(kernel=<span class="string">'linear'</span>, probability=<span class="literal">True</span>, random_state=rseed)</span><br><span class="line">    svm_perf = measure_cl_perf(cl, <span class="string">'SVMlin'</span>, *data)</span><br><span class="line">    perf = concat_dicts(perf, svm_perf)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> perf</span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDIwMDQvMDQvMTU4NTk5MzY5NF84MDQwMzYucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="ELU激活函数"><a href="#ELU激活函数" class="headerlink" title="ELU激活函数"></a>ELU激活函数</h3><p><img src="https://img-blog.csdn.net/20161120172142224#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20160917160040231#pic_center" alt="在这里插入图片描述"><br>特点：</p>
<ul>
<li>融合了sigmoid和ReLU，左侧具有软饱和性，右侧无饱和性。</li>
<li>右侧线性部分使得ELU能够缓解梯度消失，而左侧软饱能够让ELU对输入变化或噪声更鲁棒。</li>
<li>ELU的输出均值接近于零，所以收敛速度更快。</li>
</ul>
<h3 id="MMD"><a href="#MMD" class="headerlink" title="MMD"></a>MMD</h3><p>MMD（最大均值差异）是迁移学习，尤其是Domain adaptation （域适应）中使用最广泛（目前）的一种损失函数，主要用来度量两个不同但相关的分布的距离。</p>
<h3 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h3><p>是一种量化两种概率分布P和Q之间差异的方式，又叫相对熵。K-L散度能帮助我们度量使用一个分布来近似另一个分布时所损失的信息量。</p>
<h3 id="细胞系"><a href="#细胞系" class="headerlink" title="细胞系"></a>细胞系</h3><p>细胞系（cell line）指原代细胞培养物经首次传代成功后所繁殖的细胞群体。 也指可长期连续传代的培养细胞。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><h4 id="文章："><a href="#文章：" class="headerlink" title="文章："></a>文章：</h4><p>(VAE)<a href="https://blog.csdn.net/weixin_40955254/article/details/82315224" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40955254/article/details/82315224</a><br>(VAE)<a href="https://blog.csdn.net/cjh_jinduoxia/article/details/84995156" target="_blank" rel="noopener">https://blog.csdn.net/cjh_jinduoxia/article/details/84995156</a><br>(KL散度)<a href="https://www.jianshu.com/p/43318a3dc715?isappinstalled=0" target="_blank" rel="noopener">https://www.jianshu.com/p/43318a3dc715?isappinstalled=0</a></p>
<h4 id="视频："><a href="#视频：" class="headerlink" title="视频："></a>视频：</h4><p>（白板推导VAE）<a href="https://www.bilibili.com/video/BV15E411w7Pz" target="_blank" rel="noopener">https://www.bilibili.com/video/BV15E411w7Pz</a></p>
</div></div><a class="button-hover more" href="2020/04/01/srf之论文阅读Dr.VAE/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/03/29/srf之论文汇报流程/">srf之论文汇报流程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="categories/DeepLearning/">DeepLearning</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="tags/srf/">srf</a></div></div><div class="post-content"><div class="main-content content"><h2 id="论文将要讲述的方面"><a href="#论文将要讲述的方面" class="headerlink" title="论文将要讲述的方面"></a>论文将要讲述的方面</h2><ol>
<li>为什么要讲这个?（背景）</li>
<li>提出了什么 <strong>方法</strong> ?</li>
<li>传统方法有什么问题?（<strong>对比</strong>）</li>
<li><strong>原理</strong>简单讲一讲（数学方面要求不是很高，有代码实现更方便）?</li>
<li><strong>数据集</strong>是怎么<strong>划分</strong>的?</li>
<li><strong>交叉验证</strong>怎么做?</li>
</ol>
<h2 id="研究方法和主题"><a href="#研究方法和主题" class="headerlink" title="研究方法和主题"></a>研究方法和主题</h2><p>学长说在GCN方面不会有更深入的探寻了，会在以下几个方面找突破口</p>
<ul>
<li>Attention机制</li>
<li>知识图谱</li>
<li>异构图网络的学习</li>
<li>嵌入式学习</li>
</ul>
<h2 id="论文的选取"><a href="#论文的选取" class="headerlink" title="论文的选取"></a>论文的选取</h2><blockquote>
<p><strong>新</strong>（前沿），在期刊上发表的更好<br>有代码最好，有名字的模型在github上可以搜索的到</p>
</blockquote>
<h2 id="学长目前的想法"><a href="#学长目前的想法" class="headerlink" title="学长目前的想法"></a>学长目前的想法</h2><ul>
<li>SMILES收集之后：通过label encoding提取smiles的embedding<br><img src="srf%E4%B9%8B%E8%AE%BA%E6%96%87%E6%B1%87%E6%8A%A5%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></li>
</ul>
</div></div><a class="button-hover more" href="2020/03/29/srf之论文汇报流程/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/26/web小项目/">Web小项目(react调试和部署)</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-03-29</time></div><div class="post-content"><div class="main-content content"><h2 id="如何在本地调试react项目"><a href="#如何在本地调试react项目" class="headerlink" title="如何在本地调试react项目"></a>如何在本地调试react项目</h2><blockquote>
<p>在项目终端下(pycharm)运行 <figure class="highlight plain"><figcaption><span>install```**安装依赖**</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">项目会生成**node_modules**目录</span><br><span class="line"></span><br><span class="line">我们在在项目终端下(pycharm)运行</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>npm start</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">浏览器会自动打开http://localhost:3000运行调试</span><br><span class="line"></span><br><span class="line">## 如何将本地的react项目部署到云服务器上</span><br><span class="line">我们在在项目终端下(pycharm)运行</span><br></pre></td></tr></table></figure>

<p>npm run build</p>
<pre><code>项目会生成了一个**build**目录

打开宝塔服务器页面，到相关网站下，将build页面下==static上传，以及和static平行的文件上传。==

至此，大功告成！
tips:感觉网上的教程大多数很复杂，暂时也不太明白他们做的原理(TODO)</code></pre></div></div><a class="button-hover more" href="2020/02/26/web小项目/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/25/爬虫之selenium报错——Chromedriver/">爬虫之selenium报错——Chromedriver</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-02</time></div><div class="post-content"><div class="main-content content"><p><strong>报错信息：</strong></p>
<figure class="highlight plain"><figcaption><span>executable needs to be in PATH.```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**解决方法：**</span><br><span class="line">### 关于Chromedriver如何配置环境变量问题解决[^1]</span><br><span class="line">到环境变量中加上‪C:\Program Files (x86)\Google\Chrome\Application</span><br><span class="line"></span><br><span class="line">### windows下更新环境变量不需要重启系统快速生效的方法[^2]</span><br></pre></td></tr></table></figure>

<p>set path=test<br>echo %path%<br>```</p>
<h3 id="如果还没有生效的话-3"><a href="#如果还没有生效的话-3" class="headerlink" title="如果还没有生效的话[^3]"></a>如果还没有生效的话[^3]</h3><p><strong>原来还要放到Python目录下</strong><br>很多人都反应上面两步做了也没有生效</p>
<p>最后……<br>自己入自己的坑，才是最绝望的。chromedriver和chrome 多少是眼残的事……</p>
<p>参考：<br>[^1]: <a href="https://blog.csdn.net/qq_41429288/article/details/80472064" target="_blank" rel="noopener">https://blog.csdn.net/qq_41429288/article/details/80472064</a><br>[^2]: <a href="https://blog.csdn.net/u010770041/article/details/49915089" target="_blank" rel="noopener">https://blog.csdn.net/u010770041/article/details/49915089</a><br>[^3]: <a href="https://blog.csdn.net/weixin_37185329/article/details/80493281" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37185329/article/details/80493281</a></p>
</div></div><a class="button-hover more" href="2020/02/25/爬虫之selenium报错——Chromedriver/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/23/ideaVim-easymotion 插件/">ideaVim-easymotion 插件</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-02</time></div><div class="post-content"><div class="main-content content"><h4 id="作用：辅助（优化）ideaVim的"><a href="#作用：辅助（优化）ideaVim的" class="headerlink" title="作用：辅助（优化）ideaVim的"></a>作用：辅助（优化）ideaVim的</h4><p>主要是通过提升了<strong>跳转</strong>方式<br>一般的：<br><code>gg, G</code>最上、最下<br><code>Ctrl-D/U</code>下几步，上几步</p>
<p>网上教程不多，具体更多详细教程：<br><a href="http://www.wklken.me/posts/2015/06/07/vim-plugin-easymotion.html" target="_blank" rel="noopener">http://www.wklken.me/posts/2015/06/07/vim-plugin-easymotion.html</a></p>
</div></div><a class="button-hover more" href="2020/02/23/ideaVim-easymotion 插件/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/22/解决IDEA和Pycharm中Vim插件不能与外界粘贴复制/">解决IDEA和Pycharm中Vim插件不能与外界粘贴复制</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-02</time></div><div class="post-content"><div class="main-content content"><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul>
<li><strong>vim 缓冲区</strong>和<strong>系统剪贴板</strong><br>vim 里面粘贴复制实际上是在vim 缓冲区 存取数据，而系统的ctry+c ctry+v 是与系统剪贴板之间的交互<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3></li>
<li>tools工具下点<strong>vim emulation</strong>，再<strong>重新复制</strong><br>（<em>感觉这的确还是很麻烦，但是暂时没有找到更好的办法了</em>）</li>
</ul>
</div></div><a class="button-hover more" href="2020/02/22/解决IDEA和Pycharm中Vim插件不能与外界粘贴复制/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="2020/02/20/Java垃圾回收机制/">Java垃圾回收机制</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-03</time><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="tags/Java/">Java</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><h2 id="垃圾回收的意义"><a href="#垃圾回收的意义" class="headerlink" title="垃圾回收的意义"></a>垃圾回收的意义</h2><p>在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。<br>事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。</p>
<h3 id="这使Java-虚拟机具有一些优点"><a href="#这使Java-虚拟机具有一些优点" class="headerlink" title="这使Java 虚拟机具有一些优点"></a>这使Java 虚拟机具有一些优点</h3><ul>
<li>首先，它能<strong>使编程效率提高</strong>。在没有垃圾回收机制的时候，可能要花许多时间来解决一个<strong>难懂的存储器问题。</strong></li>
<li>其次是它<strong>保护程序的完整性</strong>（？）， 垃圾回收是Java语言安全性策略的一个重要部份。</li>
</ul>
<h3 id="垃圾回收的一个潜在的缺点是它的开销影响程序性能。"><a href="#垃圾回收的一个潜在的缺点是它的开销影响程序性能。" class="headerlink" title="垃圾回收的一个潜在的缺点是它的开销影响程序性能。"></a>垃圾回收的一个潜在的缺点是它的<strong>开销影响程序性能</strong>。</h3><ul>
<li>Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要<strong>花费处理器的时间。</strong></li>
<li>其次<strong>垃圾回收算法的不完备性</strong>，<em>早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。</em>随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。</li>
</ul>
<h2 id="垃圾收集的算法分析"><a href="#垃圾收集的算法分析" class="headerlink" title="垃圾收集的算法分析"></a>垃圾收集的算法分析</h2><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：<br>**1. 发现无用信息对象</p>
<ol start="2">
<li>回收被无用对象占用的内存空间，使该空间可被程序再次使用。**</li>
</ol>
<blockquote>
<p>大多数垃圾回收算法使用了<strong>根集(root set)</strong>这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃圾回收首先需要确定从根开始 <strong>哪些是可达的和哪些是不可达的</strong>，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。</p>
</blockquote>
<h3 id="1-引用计数法-Reference-Counting-Collector"><a href="#1-引用计数法-Reference-Counting-Collector" class="headerlink" title="1. 引用计数法(Reference Counting Collector)"></a>1. 引用计数法(Reference Counting Collector)</h3><p>引用计数法是<strong>唯一没有使用根集的</strong>垃圾回收的算法，该算法使用引用计数器来区分存活对象和不再使用的对象。堆中的每个对象对应一个引用计数器。<em>计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。</em><br>引用计数算法实现简单，效率很高，微软的COM技术、ActionScript、Python等都使用了引用计数算法进行内存管理，但是引用计数算法对于对象之间相互循环引用问题难以解决，因此java并没有使用引用计数算法。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>基于引用计数器的垃圾收集器运行较<strong>快</strong>，<em>对程序需要不被长时间打断的实时环境比较有利。</em></p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p> <strong>无法检测出循环引用</strong>如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0. 而且每次加减<strong>非常浪费内存</strong>。</p>
<h3 id="2-tracing算法-Tracing-Collector"><a href="#2-tracing算法-Tracing-Collector" class="headerlink" title="2. tracing算法(Tracing Collector)"></a>2. tracing算法(Tracing Collector)</h3><p>tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.</p>
<h3 id="3-compacting算法-Compacting-Collector"><a href="#3-compacting算法-Compacting-Collector" class="headerlink" title="3. compacting算法(Compacting Collector)"></a>3. compacting算法(Compacting Collector)</h3><p>为了<strong>解决堆碎片问题</strong>，基于tracing的垃圾回收吸收了<strong>Compacting算法</strong>的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加<strong>句柄和句柄表</strong>。</p>
<p>标记-整理算法在标记-清除算法基础上做了改进，标记阶段是相同的标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。<br>标记-整理算法相比标记-清除算法的优点是内存<strong>被整理以后不会产生大量不连续内存碎片问题。</strong><br>复制算法在<strong>对象存活率高的情况下</strong>就要执行较多的复制操作，效率将会变低，而在对象存活率高的情况下使用标记-整理算法效率会大大提高。</p>
<h3 id="4-copying（复制）算法-Coping-Collector"><a href="#4-copying（复制）算法-Coping-Collector" class="headerlink" title="4. copying（复制）算法(Coping Collector)"></a>4. copying（复制）算法(Coping Collector)</h3><p>该算法的提出是为了<strong>克服句柄的开销和解决堆碎片的垃圾回收</strong>。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。<br>一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，在对象区与空闲区域的切换过程中，程序暂停执行。</p>
<p>S0和s1将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>可使用的内存降为原来一半。</p>
<p>复制算法用于在<strong>新生代垃圾回收</strong></p>
<h3 id="5-generation（分代收集）算法-Generational-Collector"><a href="#5-generation（分代收集）算法-Generational-Collector" class="headerlink" title="5. generation（分代收集）算法(Generational Collector)"></a>5. generation（分代收集）算法(Generational Collector)</h3><p>stop-and-copy垃圾收集器的一个缺陷是<strong>收集器必须复制所有的活动对象</strong>，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代(generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。</p>
<p>根据内存中对象的存活周期不同，将内存划分为几块，java的虚拟机中一般把内存划分为新生代和年老代，当新创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中，当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。<br>对于新生代和老年代来说,新生代回收频率很高,但是每次回收耗时很短,而老年代回收频率较低,但是耗时会相对较长,所以应该尽量减少老年代的GC.</p>
<h3 id="6-adaptive算法-Adaptive-Collector"><a href="#6-adaptive算法-Adaptive-Collector" class="headerlink" title="6. adaptive算法(Adaptive Collector)"></a>6. adaptive算法(Adaptive Collector)</h3><p>　　在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p>
<h2 id="System-gc-方法"><a href="#System-gc-方法" class="headerlink" title="System.gc()方法"></a>System.gc()方法</h2><p>使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestGC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">　　    <span class="keyword">new</span> TestGC();</span><br><span class="line">　　    System.gc();</span><br><span class="line">　　    System.runFinalization();</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips:调用System.gc()也仅仅是一个<strong>请求(建议)</strong>。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。</p>
<h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h2><p>之所以要使用finalize()，是存在着<strong>垃圾回收器不能处理的特殊情况</strong>。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。</p>
<p>特殊的区域如：</p>
<ol>
<li>由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。</li>
<li>又或者打开的<strong>文件资源</strong>，这些资源不属于垃圾回收器的回收范围。</li>
</ol>
<h2 id="触发主GC（Garbage-Collector）的条件"><a href="#触发主GC（Garbage-Collector）的条件" class="headerlink" title="触发主GC（Garbage Collector）的条件"></a>触发主GC（Garbage Collector）的条件</h2><p>JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。<br>总的来说,有两个条件会触发主GC:</p>
<ol>
<li>当<strong>没有应用线程在运行时</strong>,GC会被调用。因为<strong>GC在优先级最低的线程中进行</strong>,所以当应用忙时,GC线程就不会被调用,但以下条件除外。</li>
<li><strong>Java堆内存不足时</strong>,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,<strong>JVM会再进行两次GC</strong>作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。</li>
</ol>
<h2 id="减少GC开销的措施"><a href="#减少GC开销的措施" class="headerlink" title="减少GC开销的措施"></a>减少GC开销的措施</h2><h3 id="1-不要显式调用System-gc"><a href="#1-不要显式调用System-gc" class="headerlink" title="1. 不要显式调用System.gc()"></a>1. 不要显式调用System.gc()</h3><p> 此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</p>
<h3 id="2-尽量减少临时对象的使用"><a href="#2-尽量减少临时对象的使用" class="headerlink" title="2. 尽量减少临时对象的使用"></a>2. 尽量减少临时对象的使用</h3><p> 临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</p>
<h3 id="3-对象不用时最好显式置为Null"><a href="#3-对象不用时最好显式置为Null" class="headerlink" title="3. 对象不用时最好显式置为Null"></a>3. 对象不用时最好显式置为Null</h3><p> 为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</p>
<h3 id="4-尽量使用StringBuffer-而不用String来累加字符串"><a href="#4-尽量使用StringBuffer-而不用String来累加字符串" class="headerlink" title="4. 尽量使用StringBuffer,而不用String来累加字符串"></a>4. 尽量使用StringBuffer,而不用String来累加字符串</h3><p>  由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</p>
<h3 id="5-能用基本类型如Int-Long-就不用Integer-Long对象"><a href="#5-能用基本类型如Int-Long-就不用Integer-Long对象" class="headerlink" title="5.  能用基本类型如Int,Long,就不用Integer,Long对象"></a>5.  能用基本类型如Int,Long,就不用Integer,Long对象</h3><p>基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</p>
<h3 id="6-尽量少用静态对象变量"><a href="#6-尽量少用静态对象变量" class="headerlink" title="6. 尽量少用静态对象变量"></a>6. 尽量少用静态对象变量</h3><p>静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</p>
<h3 id="7-分散对象创建或删除的时间"><a href="#7-分散对象创建或删除的时间" class="headerlink" title="7. 分散对象创建或删除的时间"></a>7. 分散对象创建或删除的时间</h3><p>集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chair</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">boolean</span> gcrun = <span class="keyword">false</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">boolean</span> f = <span class="keyword">false</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">int</span> created = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">int</span> finalized = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">　　Chair() &#123;</span><br><span class="line">　　    i = ++created;</span><br><span class="line">　　    <span class="keyword">if</span>(created == <span class="number">47</span>)</span><br><span class="line">　　　      System.out.println(<span class="string">"Created 47"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　    <span class="keyword">if</span>(!gcrun) &#123;</span><br><span class="line">　　　      gcrun = <span class="keyword">true</span>;</span><br><span class="line">　　　      System.out.println(<span class="string">"Beginning to finalize after "</span> + created + <span class="string">" Chairs have been created"</span>);</span><br><span class="line">　　    &#125;</span><br><span class="line">　　    <span class="keyword">if</span>(i == <span class="number">47</span>) &#123;</span><br><span class="line">　　　      System.out.println(<span class="string">"Finalizing Chair #47， "</span> +<span class="string">"Setting flag to stop Chair creation"</span>);</span><br><span class="line">　　　      f = <span class="keyword">true</span>;</span><br><span class="line">　　    &#125;</span><br><span class="line">　　    finalized++;</span><br><span class="line">　　    <span class="keyword">if</span>(finalized &gt;= created)</span><br><span class="line">　　　      System.out.println(<span class="string">"All "</span> + finalized + <span class="string">" finalized"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Garbage</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span>(args.length == <span class="number">0</span>) &#123;</span><br><span class="line">　　　  System.err.println(<span class="string">"Usage: /n"</span> + <span class="string">"java Garbage before/n or:/n"</span> + <span class="string">"java Garbage after"</span>);</span><br><span class="line">　　　  <span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">while</span>(!Chair.f) &#123;</span><br><span class="line">　　　  <span class="keyword">new</span> Chair();</span><br><span class="line">　　　  <span class="keyword">new</span> String(<span class="string">"To take up space"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　System.out.println(<span class="string">"After all Chairs have been created:/n"</span> + <span class="string">"total created = "</span> + Chair.created +</span><br><span class="line">　　<span class="string">"， total finalized = "</span> + Chair.finalized);</span><br><span class="line">　　<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"before"</span>)) &#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"gc():"</span>);</span><br><span class="line">　　　　System.gc();</span><br><span class="line">　　　　System.out.println(<span class="string">"runFinalization():"</span>);</span><br><span class="line">　　　　System.runFinalization();</span><br><span class="line">　　&#125;</span><br><span class="line">　　System.out.println(<span class="string">"bye!"</span>);</span><br><span class="line">　　<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"after"</span>))</span><br><span class="line">　　　  System.runFinalizersOnExit(<span class="keyword">true</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这个程序创建了许多Chair对象，而且在垃圾收集器开始运行后的某些时候，程序会停止创建Chair。由于垃圾收集器可能在任何时间运行，所以我们不能准确知道它在何时启动。因此，程序用一个名为gcrun的标记来指出垃圾收集器是否已经开始运行。利用第二个标记f，Chair可告诉main()它应停止对象的生成。这两个标记都是在finalize()内部设置的，它调用于垃圾收集期间。另两个static变量–created以及 finalized–分别用于跟踪已创建的对象数量以及垃圾收集器已进行完收尾工作的对象数量。最后，每个Chair都有它自己的（非 static）int i，所以能跟踪了解它具体的编号是多少。编号为47的Chair进行完收尾工作后，标记会设为true，最终结束Chair对象的创建过程。</p>
</blockquote>
<h2 id="关于垃圾回收的几点补充"><a href="#关于垃圾回收的几点补充" class="headerlink" title="关于垃圾回收的几点补充"></a>关于垃圾回收的几点补充</h2><ul>
<li>垃圾收集发生的<strong>不可预知性</strong>：由于实现了不同的垃圾回收算法和采用了不同的收集机制，所以它有可能是定时发生，有可能是当出现系统空闲CPU资源时发生，也有可能是和原始的垃圾收集一样，等到内存消耗出现极限时发生，这与垃圾收集器的选择和具体的设置都有关系。</li>
<li>垃圾收集的实现和<strong>具体的JVM 以及JVM的内存模型</strong>有非常紧密的关系。不同的JVM 可能采用不同的垃圾收集，而<strong>JVM 的内存模型决定着该JVM可以采用哪些类型垃圾收集</strong>。现在，<strong>HotSpot 系列</strong>JVM中的内存系统都采用先进的面向对象的框架设计，这使得该系列JVM都可以采用最先进的垃圾收集。</li>
<li><strong>尽早释放无用对象的引用。</strong>大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的<strong>对象是否被监听</strong>，如果有，则要<strong>去掉监听器，然后再赋空值</strong>。</li>
<li>关键的也是难把握的问题是<strong>内存泄漏</strong>。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。</li>
</ul>
<p>博客参考：<br><a href="https://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="noopener">https://blog.csdn.net/zsuguangh/article/details/6429592</a><br><a href="https://blog.csdn.net/zhangcongyi420/article/details/89060970" target="_blank" rel="noopener">https://blog.csdn.net/zhangcongyi420/article/details/89060970</a></p>
</div></div><a class="button-hover more" href="2020/02/20/Java垃圾回收机制/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="page/5/">5</a><a class="extend next" rel="next" href="page/2/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By Rr-shan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>