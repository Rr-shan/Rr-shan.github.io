<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="排序算法（C++实现）"><meta name="keywords" content="algorithm"><meta name="author" content="Rr-shan,undefined"><meta name="copyright" content="Rr-shan"><title>排序算法（C++实现）【Sanzzi】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-冒泡算法"><span class="toc-number">1.</span> <span class="toc-text">1. 冒泡算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-选择排序"><span class="toc-number">2.</span> <span class="toc-text">2. 选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-插入排序"><span class="toc-number">3.</span> <span class="toc-text">3. 插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-快速排序法"><span class="toc-number">4.</span> <span class="toc-text">4. 快速排序法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-堆排序"><span class="toc-number">5.</span> <span class="toc-text">5. 堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-归并排序"><span class="toc-number">6.</span> <span class="toc-text">6. 归并排序</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Rr-shan</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/Rr-shan" target="_blank">GitHub<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="mailto:1224559633@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color10"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">13</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">4</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Sanzzi</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">排序算法（C++实现）</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-10-23 | 更新于 2019-11-09</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/algorithm/">algorithm</a></div></div></div><div class="main-content"><h2 id="1-冒泡算法"><a href="#1-冒泡算法" class="headerlink" title="1. 冒泡算法"></a>1. 冒泡算法</h2><ul>
<li>思想：两两比大小，两两交换，可以改进</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//如果某一次遍历没有发生一次交换，则说明有序，不用继续遍历</span><br><span class="line">void maopao2(vector&lt;int&gt; &amp;arr)</span><br><span class="line">&#123;</span><br><span class="line">    bool flag = true;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = false;</span><br><span class="line">        for(int j = 0 ;j &lt; arr.size()-1-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j+1]) // 我觉得这个条件判断存在风险</span><br><span class="line">            &#123;</span><br><span class="line">                int t = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = t;</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><ul>
<li>思想：每一次从未排序元素中选择最小的元素，采用记下标的方式记录，比当前小，则记下下标，最后与最前面的未排序元素交换。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void ChooseSort(vector&lt;int&gt; &amp;arr)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0;i &lt; arr.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp = i;</span><br><span class="line">        for(int j = i+1;j &lt; arr.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(arr[j] &lt; arr[temp])</span><br><span class="line">                temp = j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i != temp)</span><br><span class="line">        &#123;</span><br><span class="line">            int t = arr[temp];</span><br><span class="line">            arr[temp] = arr[i];</span><br><span class="line">            arr[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><ul>
<li>降序：选取元素依次与之前的有序比较，比之大，则将元素往后移动，直到找到比之小的元素或者到头，将该元素插入即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(vector&lt;int&gt; &amp;arr)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1;i &lt; arr.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j = i;</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        while(j-1 &gt;= 0 &amp;&amp; temp &lt; arr[j-1])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j-1];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-快速排序法"><a href="#4-快速排序法" class="headerlink" title="4. 快速排序法"></a>4. 快速排序法</h2><ul>
<li>思想：二分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(vector&lt;int&gt; &amp;arr,int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left &gt;= right)</span><br><span class="line">        return;</span><br><span class="line">    int oldleft = left;</span><br><span class="line">    int oldright = right;</span><br><span class="line">    int pivot = arr[left];</span><br><span class="line">    while(left &lt; right)//越界一定研严格小于！</span><br><span class="line">    &#123;</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[right] &gt;= pivot)//防止相等元素无限循环，加上=号，只选择严格小于</span><br><span class="line">            right--;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[left] &lt;= pivot)</span><br><span class="line">            left++;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = pivot;</span><br><span class="line">    QuickSort(arr,oldleft,left-1);</span><br><span class="line">    QuickSort(arr,left+1,oldright);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a>5. 堆排序</h2><ul>
<li>思想：模拟二叉树，对于每个父亲节点i，2<em>i+1为左儿子，2</em>i+2为右儿子，调整堆时，需要以父亲节点的身份调整有2*i+1&lt;=n-1(身为父亲至少有一个左儿子，且左儿子在此数组内)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void adjHeap(vector&lt;int&gt; &amp;arr,int i,int n)//小根堆</span><br><span class="line">&#123;</span><br><span class="line">    if(i &lt;= n/2 - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        int j = 2*i+1;</span><br><span class="line">        if(j + 1 &lt;= n - 1 &amp;&amp; arr[j+1] &lt; arr[j])</span><br><span class="line">            j++;//若有右儿子，选取两者较小的一个</span><br><span class="line">        if(arr[j] &lt; arr[i])//儿子比父亲小</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">            adjHeap(arr,j,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(vector&lt;int&gt; &amp;arr,int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = n/2 - 1;i &gt;=0;i--)//从最后的父节点开始调整建立堆</span><br><span class="line">    &#123;</span><br><span class="line">        adjHeap(arr,i,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = n-1;i &gt; 0;i--)//每次将最小的与后面的元素交换，再从跟开始调整</span><br><span class="line">    &#123;</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[0];</span><br><span class="line">        arr[0] = temp;</span><br><span class="line">        adjHeap(arr,0,i);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h2><ul>
<li>思想：将列表从正中间分为两个子列表；<br>按照第一步，递归拆分每个子列表，直至子列表最大长度为1；<br>按照拆分层级，依次按大小合并各子列表，直至全部合并完成。<br>分治法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void Merge(vector&lt;int&gt; &amp;arr,int left,int mid,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left &gt;= right)</span><br><span class="line">        return;</span><br><span class="line">    int i = left;</span><br><span class="line">    int j = mid + 1;</span><br><span class="line">    int k = left;</span><br><span class="line">    vector&lt;int&gt; temp(arr.size(),0);</span><br><span class="line">    while(i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i] &lt; arr[j])</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt;= mid)</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    while(j &lt;= right)</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    for(int i = left;i &lt;= right;i++)</span><br><span class="line">        arr[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSort(vector&lt;int&gt; &amp;arr,int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left &gt;= right)</span><br><span class="line">        return;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = (left+right)/2;</span><br><span class="line">        MergeSort(arr,left,mid);</span><br><span class="line">        MergeSort(arr,mid+1,right);</span><br><span class="line">        Merge(arr,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rr-shan</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://rr-shan.github.io/2019/10/23/排序算法/">https://rr-shan.github.io/2019/10/23/排序算法/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rr-shan.github.io">Sanzzi</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/10/24/机器学习初步/"><i class="fas fa-angle-left">&nbsp;</i><span>机器学习初步</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/10/20/COF23/"><span>GOF23</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2019 By Rr-shan</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>